/* automatically generated by rust-bindgen 0.68.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const JSC_OBJC_API_ENABLED: u32 = 0;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSContextGroup {
    _unused: [u8; 0],
}
#[doc = " @typedef JSContextGroupRef A group that associates JavaScript contexts with one another. Contexts in the same group may share and exchange JavaScript objects."]
pub type JSContextGroupRef = *const OpaqueJSContextGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSContext {
    _unused: [u8; 0],
}
#[doc = " @typedef JSContextRef A JavaScript execution context. Holds the global object and other execution state."]
pub type JSContextRef = *const OpaqueJSContext;
#[doc = " @typedef JSGlobalContextRef A global JavaScript execution context. A JSGlobalContext is a JSContext."]
pub type JSGlobalContextRef = *mut OpaqueJSContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSString {
    _unused: [u8; 0],
}
#[doc = " @typedef JSStringRef A UTF16 character buffer. The fundamental string representation in JavaScript."]
pub type JSStringRef = *mut OpaqueJSString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSClass {
    _unused: [u8; 0],
}
#[doc = " @typedef JSClassRef A JavaScript class. Used with JSObjectMake to construct objects with custom behavior."]
pub type JSClassRef = *mut OpaqueJSClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSPropertyNameArray {
    _unused: [u8; 0],
}
#[doc = " @typedef JSPropertyNameArrayRef An array of JavaScript property names."]
pub type JSPropertyNameArrayRef = *mut OpaqueJSPropertyNameArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSPropertyNameAccumulator {
    _unused: [u8; 0],
}
#[doc = " @typedef JSPropertyNameAccumulatorRef An ordered set used to collect the names of a JavaScript object's properties."]
pub type JSPropertyNameAccumulatorRef = *mut OpaqueJSPropertyNameAccumulator;
#[doc = " @typedef JSTypedArrayBytesDeallocator A function used to deallocate bytes passed to a Typed Array constructor. The function should take two arguments. The first is a pointer to the bytes that were originally passed to the Typed Array constructor. The second is a pointer to additional information desired at the time the bytes are to be freed."]
pub type JSTypedArrayBytesDeallocator = ::std::option::Option<
    unsafe extern "C" fn(
        bytes: *mut ::std::os::raw::c_void,
        deallocatorContext: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSValue {
    _unused: [u8; 0],
}
#[doc = " @typedef JSValueRef A JavaScript value. The base type for all JavaScript values, and polymorphic functions on them."]
pub type JSValueRef = *const OpaqueJSValue;
#[doc = " @typedef JSObjectRef A JavaScript object. A JSObject is a JSValue."]
pub type JSObjectRef = *mut OpaqueJSValue;
extern "C" {
    #[doc = "@function JSEvaluateScript\n@abstract Evaluates a string of JavaScript.\n@param ctx The execution context to use.\n@param script A JSString containing the script to evaluate.\n@param thisObject The object to use as \"this,\" or NULL to use the global object as \"this.\"\n@param sourceURL A JSString containing a URL for the script's source file. This is used by debuggers and when reporting exceptions. Pass NULL if you do not care to include source file information.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The JSValue that results from evaluating script, or NULL if an exception is thrown."]
    pub fn JSEvaluateScript(
        ctx: JSContextRef,
        script: JSStringRef,
        thisObject: JSObjectRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function JSCheckScriptSyntax\n@abstract Checks for syntax errors in a string of JavaScript.\n@param ctx The execution context to use.\n@param script A JSString containing the script to check for syntax errors.\n@param sourceURL A JSString containing a URL for the script's source file. This is only used when reporting exceptions. Pass NULL if you do not care to include source file information in exceptions.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store a syntax error exception, if any. Pass NULL if you do not care to store a syntax error exception.\n@result true if the script is syntactically correct, otherwise false."]
    pub fn JSCheckScriptSyntax(
        ctx: JSContextRef,
        script: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function JSGarbageCollect\n@abstract Performs a JavaScript garbage collection.\n@param ctx The execution context to use.\n@discussion JavaScript values that are on the machine stack, in a register,\nprotected by JSValueProtect, set as the global object of an execution context,\nor reachable from any such value will not be collected.\n\nDuring JavaScript execution, you are not required to call this function; the\nJavaScript engine will garbage collect as needed. JavaScript values created\nwithin a context group are automatically destroyed when the last reference\nto the context group is released."]
    pub fn JSGarbageCollect(ctx: JSContextRef);
}
pub const JSType_kJSTypeUndefined: JSType = 0;
pub const JSType_kJSTypeNull: JSType = 1;
pub const JSType_kJSTypeBoolean: JSType = 2;
pub const JSType_kJSTypeNumber: JSType = 3;
pub const JSType_kJSTypeString: JSType = 4;
pub const JSType_kJSTypeObject: JSType = 5;
pub const JSType_kJSTypeSymbol: JSType = 6;
#[doc = "@enum JSType\n@abstract     A constant identifying the type of a JSValue.\n@constant     kJSTypeUndefined  The unique undefined value.\n@constant     kJSTypeNull       The unique null value.\n@constant     kJSTypeBoolean    A primitive boolean value, one of true or false.\n@constant     kJSTypeNumber     A primitive number value.\n@constant     kJSTypeString     A primitive string value.\n@constant     kJSTypeObject     An object value (meaning that this JSValueRef is a JSObjectRef).\n@constant     kJSTypeSymbol     A primitive symbol value."]
pub type JSType = ::std::os::raw::c_int;
pub const JSTypedArrayType_kJSTypedArrayTypeInt8Array: JSTypedArrayType = 0;
pub const JSTypedArrayType_kJSTypedArrayTypeInt16Array: JSTypedArrayType = 1;
pub const JSTypedArrayType_kJSTypedArrayTypeInt32Array: JSTypedArrayType = 2;
pub const JSTypedArrayType_kJSTypedArrayTypeUint8Array: JSTypedArrayType = 3;
pub const JSTypedArrayType_kJSTypedArrayTypeUint8ClampedArray: JSTypedArrayType = 4;
pub const JSTypedArrayType_kJSTypedArrayTypeUint16Array: JSTypedArrayType = 5;
pub const JSTypedArrayType_kJSTypedArrayTypeUint32Array: JSTypedArrayType = 6;
pub const JSTypedArrayType_kJSTypedArrayTypeFloat32Array: JSTypedArrayType = 7;
pub const JSTypedArrayType_kJSTypedArrayTypeFloat64Array: JSTypedArrayType = 8;
pub const JSTypedArrayType_kJSTypedArrayTypeArrayBuffer: JSTypedArrayType = 9;
pub const JSTypedArrayType_kJSTypedArrayTypeNone: JSTypedArrayType = 10;
pub const JSTypedArrayType_kJSTypedArrayTypeBigInt64Array: JSTypedArrayType = 11;
pub const JSTypedArrayType_kJSTypedArrayTypeBigUint64Array: JSTypedArrayType = 12;
#[doc = "@enum JSTypedArrayType\n@abstract     A constant identifying the Typed Array type of a JSObjectRef.\n@constant     kJSTypedArrayTypeInt8Array            Int8Array\n@constant     kJSTypedArrayTypeInt16Array           Int16Array\n@constant     kJSTypedArrayTypeInt32Array           Int32Array\n@constant     kJSTypedArrayTypeUint8Array           Uint8Array\n@constant     kJSTypedArrayTypeUint8ClampedArray    Uint8ClampedArray\n@constant     kJSTypedArrayTypeUint16Array          Uint16Array\n@constant     kJSTypedArrayTypeUint32Array          Uint32Array\n@constant     kJSTypedArrayTypeFloat32Array         Float32Array\n@constant     kJSTypedArrayTypeFloat64Array         Float64Array\n@constant     kJSTypedArrayTypeBigInt64Array        BigInt64Array\n@constant     kJSTypedArrayTypeBigUint64Array       BigUint64Array\n@constant     kJSTypedArrayTypeArrayBuffer          ArrayBuffer\n@constant     kJSTypedArrayTypeNone                 Not a Typed Array\n"]
pub type JSTypedArrayType = ::std::os::raw::c_int;
extern "C" {
    #[doc = "@function\n@abstract       Returns a JavaScript value's type.\n@param ctx  The execution context to use.\n@param value    The JSValue whose type you want to obtain.\n@result         A value of type JSType that identifies value's type."]
    pub fn JSValueGetType(ctx: JSContextRef, value: JSValueRef) -> JSType;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the undefined type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the undefined type, otherwise false."]
    pub fn JSValueIsUndefined(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the null type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the null type, otherwise false."]
    pub fn JSValueIsNull(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the boolean type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the boolean type, otherwise false."]
    pub fn JSValueIsBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the number type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the number type, otherwise false."]
    pub fn JSValueIsNumber(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the string type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the string type, otherwise false."]
    pub fn JSValueIsString(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the symbol type.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the symbol type, otherwise false."]
    pub fn JSValueIsSymbol(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the object type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the object type, otherwise false."]
    pub fn JSValueIsObject(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether a JavaScript value is an object with a given class in its class chain.\n@param ctx The execution context to use.\n@param value The JSValue to test.\n@param jsClass The JSClass to test against.\n@result true if value is an object and has jsClass in its class chain, otherwise false."]
    pub fn JSValueIsObjectOfClass(
        ctx: JSContextRef,
        value: JSValueRef,
        jsClass: JSClassRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value is an array.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value is an array, otherwise false."]
    pub fn JSValueIsArray(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether a JavaScript value is a date.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value is a date, otherwise false."]
    pub fn JSValueIsDate(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns a JavaScript value's Typed Array type.\n@param ctx          The execution context to use.\n@param value        The JSValue whose Typed Array type to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A value of type JSTypedArrayType that identifies value's Typed Array type, or kJSTypedArrayTypeNone if the value is not a Typed Array object."]
    pub fn JSValueGetTypedArrayType(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether two JavaScript values are equal, as compared by the JS == operator.\n@param ctx The execution context to use.\n@param a The first value to test.\n@param b The second value to test.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the two values are equal, false if they are not equal or an exception is thrown."]
    pub fn JSValueIsEqual(
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Tests whether two JavaScript values are strict equal, as compared by the JS === operator.\n@param ctx  The execution context to use.\n@param a        The first value to test.\n@param b        The second value to test.\n@result         true if the two values are strict equal, otherwise false."]
    pub fn JSValueIsStrictEqual(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether a JavaScript value is an object constructed by a given constructor, as compared by the JS instanceof operator.\n@param ctx The execution context to use.\n@param value The JSValue to test.\n@param constructor The constructor to test against.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if value is an object constructed by constructor, as compared by the JS instanceof operator, otherwise false."]
    pub fn JSValueIsInstanceOfConstructor(
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the undefined type.\n@param ctx  The execution context to use.\n@result         The unique undefined value."]
    pub fn JSValueMakeUndefined(ctx: JSContextRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the null type.\n@param ctx  The execution context to use.\n@result         The unique null value."]
    pub fn JSValueMakeNull(ctx: JSContextRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the boolean type.\n@param ctx  The execution context to use.\n@param boolean  The bool to assign to the newly created JSValue.\n@result         A JSValue of the boolean type, representing the value of boolean."]
    pub fn JSValueMakeBoolean(ctx: JSContextRef, boolean: bool) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the number type.\n@param ctx  The execution context to use.\n@param number   The double to assign to the newly created JSValue.\n@result         A JSValue of the number type, representing the value of number."]
    pub fn JSValueMakeNumber(ctx: JSContextRef, number: f64) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value of the string type.\n@param ctx  The execution context to use.\n@param string   The JSString to assign to the newly created JSValue. The\nnewly created JSValue retains string, and releases it upon garbage collection.\n@result         A JSValue of the string type, representing the value of string."]
    pub fn JSValueMakeString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract            Creates a JavaScript value of the symbol type.\n@param ctx           The execution context to use.\n@param description   A description of the newly created symbol value.\n@result              A unique JSValue of the symbol type, whose description matches the one provided."]
    pub fn JSValueMakeSymbol(ctx: JSContextRef, description: JSStringRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript value from a JSON formatted string.\n@param ctx      The execution context to use.\n@param string   The JSString containing the JSON string to be parsed.\n@result         A JSValue containing the parsed value, or NULL if the input is invalid."]
    pub fn JSValueMakeFromJSONString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Creates a JavaScript string containing the JSON serialized representation of a JS value.\n@param ctx      The execution context to use.\n@param value    The value to serialize.\n@param indent   The number of spaces to indent when nesting.  If 0, the resulting JSON will not contains newlines.  The size of the indent is clamped to 10 spaces.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         A JSString with the result of serialization, or NULL if an exception is thrown."]
    pub fn JSValueCreateJSONString(
        ctx: JSContextRef,
        value: JSValueRef,
        indent: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract       Converts a JavaScript value to boolean and returns the resulting boolean.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@result         The boolean result of conversion."]
    pub fn JSValueToBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract       Converts a JavaScript value to number and returns the resulting number.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         The numeric result of conversion, or NaN if an exception is thrown."]
    pub fn JSValueToNumber(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef)
        -> f64;
}
extern "C" {
    #[doc = "@function\n@abstract       Converts a JavaScript value to string and copies the result into a JavaScript string.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         A JSString with the result of conversion, or NULL if an exception is thrown. Ownership follows the Create Rule."]
    pub fn JSValueToStringCopy(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract Converts a JavaScript value to object and returns the resulting object.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         The JSObject result of conversion, or NULL if an exception is thrown."]
    pub fn JSValueToObject(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Protects a JavaScript value from garbage collection.\n@param ctx The execution context to use.\n@param value The JSValue to protect.\n@discussion Use this method when you want to store a JSValue in a global or on the heap, where the garbage collector will not be able to discover your reference to it.\n\nA value may be protected multiple times and must be unprotected an equal number of times before becoming eligible for garbage collection."]
    pub fn JSValueProtect(ctx: JSContextRef, value: JSValueRef);
}
extern "C" {
    #[doc = "@function\n@abstract       Unprotects a JavaScript value from garbage collection.\n@param ctx      The execution context to use.\n@param value    The JSValue to unprotect.\n@discussion     A value may be protected multiple times and must be unprotected an\nequal number of times before becoming eligible for garbage collection."]
    pub fn JSValueUnprotect(ctx: JSContextRef, value: JSValueRef);
}
pub const kJSPropertyAttributeNone: _bindgen_ty_1 = 0;
pub const kJSPropertyAttributeReadOnly: _bindgen_ty_1 = 2;
pub const kJSPropertyAttributeDontEnum: _bindgen_ty_1 = 4;
pub const kJSPropertyAttributeDontDelete: _bindgen_ty_1 = 8;
#[doc = "@enum JSPropertyAttribute\n@constant kJSPropertyAttributeNone         Specifies that a property has no special attributes.\n@constant kJSPropertyAttributeReadOnly     Specifies that a property is read-only.\n@constant kJSPropertyAttributeDontEnum     Specifies that a property should not be enumerated by JSPropertyEnumerators and JavaScript for...in loops.\n@constant kJSPropertyAttributeDontDelete   Specifies that the delete operation should fail on a property."]
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
#[doc = "@typedef JSPropertyAttributes\n@abstract A set of JSPropertyAttributes. Combine multiple attributes by logically ORing them together."]
pub type JSPropertyAttributes = ::std::os::raw::c_uint;
pub const kJSClassAttributeNone: _bindgen_ty_2 = 0;
pub const kJSClassAttributeNoAutomaticPrototype: _bindgen_ty_2 = 2;
#[doc = "@enum JSClassAttribute\n@constant kJSClassAttributeNone Specifies that a class has no special attributes.\n@constant kJSClassAttributeNoAutomaticPrototype Specifies that a class should not automatically generate a shared prototype for its instance objects. Use kJSClassAttributeNoAutomaticPrototype in combination with JSObjectSetPrototype to manage prototypes manually."]
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
#[doc = "@typedef JSClassAttributes\n@abstract A set of JSClassAttributes. Combine multiple attributes by logically ORing them together."]
pub type JSClassAttributes = ::std::os::raw::c_uint;
#[doc = "@typedef JSObjectInitializeCallback\n@abstract The callback invoked when an object is first created.\n@param ctx The execution context to use.\n@param object The JSObject being created.\n@discussion If you named your function Initialize, you would declare it like this:\n\nvoid Initialize(JSContextRef ctx, JSObjectRef object);\n\nUnlike the other object callbacks, the initialize callback is called on the least\nderived class (the parent class) first, and the most derived class last."]
pub type JSObjectInitializeCallback =
    ::std::option::Option<unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef)>;
#[doc = "@typedef JSObjectFinalizeCallback\n@abstract The callback invoked when an object is finalized (prepared for garbage collection). An object may be finalized on any thread.\n@param object The JSObject being finalized.\n@discussion If you named your function Finalize, you would declare it like this:\n\nvoid Finalize(JSObjectRef object);\n\nThe finalize callback is called on the most derived class first, and the least\nderived class (the parent class) last.\n\nYou must not call any function that may cause a garbage collection or an allocation\nof a garbage collected object from within a JSObjectFinalizeCallback. This includes\nall functions that have a JSContextRef parameter."]
pub type JSObjectFinalizeCallback =
    ::std::option::Option<unsafe extern "C" fn(object: JSObjectRef)>;
#[doc = "@typedef JSObjectHasPropertyCallback\n@abstract The callback invoked when determining whether an object has a property.\n@param ctx The execution context to use.\n@param object The JSObject to search for the property.\n@param propertyName A JSString containing the name of the property look up.\n@result true if object has the property, otherwise false.\n@discussion If you named your function HasProperty, you would declare it like this:\n\nbool HasProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName);\n\nIf this function returns false, the hasProperty request forwards to object's statically declared properties, then its parent class chain (which includes the default object class), then its prototype chain.\n\nThis callback enables optimization in cases where only a property's existence needs to be known, not its value, and computing its value would be expensive.\n\nIf this callback is NULL, the getProperty callback will be used to service hasProperty requests."]
pub type JSObjectHasPropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef, propertyName: JSStringRef) -> bool,
>;
#[doc = "@typedef JSObjectGetPropertyCallback\n@abstract The callback invoked when getting a property's value.\n@param ctx The execution context to use.\n@param object The JSObject to search for the property.\n@param propertyName A JSString containing the name of the property to get.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result The property's value if object has the property, otherwise NULL.\n@discussion If you named your function GetProperty, you would declare it like this:\n\nJSValueRef GetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception);\n\nIf this function returns NULL, the get request forwards to object's statically declared properties, then its parent class chain (which includes the default object class), then its prototype chain."]
pub type JSObjectGetPropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
>;
#[doc = "@typedef JSObjectSetPropertyCallback\n@abstract The callback invoked when setting a property's value.\n@param ctx The execution context to use.\n@param object The JSObject on which to set the property's value.\n@param propertyName A JSString containing the name of the property to set.\n@param value A JSValue to use as the property's value.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result true if the property was set, otherwise false.\n@discussion If you named your function SetProperty, you would declare it like this:\n\nbool SetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSValueRef* exception);\n\nIf this function returns false, the set request forwards to object's statically declared properties, then its parent class chain (which includes the default object class)."]
pub type JSObjectSetPropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectDeletePropertyCallback\n@abstract The callback invoked when deleting a property.\n@param ctx The execution context to use.\n@param object The JSObject in which to delete the property.\n@param propertyName A JSString containing the name of the property to delete.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result true if propertyName was successfully deleted, otherwise false.\n@discussion If you named your function DeleteProperty, you would declare it like this:\n\nbool DeleteProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception);\n\nIf this function returns false, the delete request forwards to object's statically declared properties, then its parent class chain (which includes the default object class)."]
pub type JSObjectDeletePropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectGetPropertyNamesCallback\n@abstract The callback invoked when collecting the names of an object's properties.\n@param ctx The execution context to use.\n@param object The JSObject whose property names are being collected.\n@param propertyNames A JavaScript property name accumulator in which to accumulate the names of object's properties.\n@discussion If you named your function GetPropertyNames, you would declare it like this:\n\nvoid GetPropertyNames(JSContextRef ctx, JSObjectRef object, JSPropertyNameAccumulatorRef propertyNames);\n\nProperty name accumulators are used by JSObjectCopyPropertyNames and JavaScript for...in loops.\n\nUse JSPropertyNameAccumulatorAddName to add property names to accumulator. A class's getPropertyNames callback only needs to provide the names of properties that the class vends through a custom getProperty or setProperty callback. Other properties, including statically declared properties, properties vended by other classes, and properties belonging to object's prototype, are added independently."]
pub type JSObjectGetPropertyNamesCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyNames: JSPropertyNameAccumulatorRef,
    ),
>;
#[doc = "@typedef JSObjectCallAsFunctionCallback\n@abstract The callback invoked when an object is called as a function.\n@param ctx The execution context to use.\n@param function A JSObject that is the function being called.\n@param thisObject A JSObject that is the 'this' variable in the function's scope.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of the  arguments passed to the function.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result A JSValue that is the function's return value.\n@discussion If you named your function CallAsFunction, you would declare it like this:\n\nJSValueRef CallAsFunction(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);\n\nIf your callback were invoked by the JavaScript expression 'myObject.myFunction()', function would be set to myFunction, and thisObject would be set to myObject.\n\nIf this callback is NULL, calling your object as a function will throw an exception."]
pub type JSObjectCallAsFunctionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        function: JSObjectRef,
        thisObject: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
>;
#[doc = "@typedef JSObjectCallAsConstructorCallback\n@abstract The callback invoked when an object is used as a constructor in a 'new' expression.\n@param ctx The execution context to use.\n@param constructor A JSObject that is the constructor being called.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of the  arguments passed to the function.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result A JSObject that is the constructor's return value.\n@discussion If you named your function CallAsConstructor, you would declare it like this:\n\nJSObjectRef CallAsConstructor(JSContextRef ctx, JSObjectRef constructor, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);\n\nIf your callback were invoked by the JavaScript expression 'new myConstructor()', constructor would be set to myConstructor.\n\nIf this callback is NULL, using your object as a constructor in a 'new' expression will throw an exception."]
pub type JSObjectCallAsConstructorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        constructor: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
>;
#[doc = "@typedef JSObjectHasInstanceCallback\n@abstract hasInstance The callback invoked when an object is used as the target of an 'instanceof' expression.\n@param ctx The execution context to use.\n@param constructor The JSObject that is the target of the 'instanceof' expression.\n@param possibleInstance The JSValue being tested to determine if it is an instance of constructor.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result true if possibleInstance is an instance of constructor, otherwise false.\n@discussion If you named your function HasInstance, you would declare it like this:\n\nbool HasInstance(JSContextRef ctx, JSObjectRef constructor, JSValueRef possibleInstance, JSValueRef* exception);\n\nIf your callback were invoked by the JavaScript expression 'someValue instanceof myObject', constructor would be set to myObject and possibleInstance would be set to someValue.\n\nIf this callback is NULL, 'instanceof' expressions that target your object will return false.\n\nStandard JavaScript practice calls for objects that implement the callAsConstructor callback to implement the hasInstance callback as well."]
pub type JSObjectHasInstanceCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        constructor: JSObjectRef,
        possibleInstance: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectConvertToTypeCallback\n@abstract The callback invoked when converting an object to a particular JavaScript type.\n@param ctx The execution context to use.\n@param object The JSObject to convert.\n@param type A JSType specifying the JavaScript type to convert to.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result The objects's converted value, or NULL if the object was not converted.\n@discussion If you named your function ConvertToType, you would declare it like this:\n\nJSValueRef ConvertToType(JSContextRef ctx, JSObjectRef object, JSType type, JSValueRef* exception);\n\nIf this function returns false, the conversion request forwards to object's parent class chain (which includes the default object class).\n\nThis function is only invoked when converting an object to number or string. An object converted to boolean is 'true.' An object converted to object is itself."]
pub type JSObjectConvertToTypeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        type_: JSType,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
>;
#[doc = "@struct JSStaticValue\n@abstract This structure describes a statically declared value property.\n@field name A null-terminated UTF8 string containing the property's name.\n@field getProperty A JSObjectGetPropertyCallback to invoke when getting the property's value.\n@field setProperty A JSObjectSetPropertyCallback to invoke when setting the property's value. May be NULL if the ReadOnly attribute is set.\n@field attributes A logically ORed set of JSPropertyAttributes to give to the property."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSStaticValue {
    pub name: *const ::std::os::raw::c_char,
    pub getProperty: JSObjectGetPropertyCallback,
    pub setProperty: JSObjectSetPropertyCallback,
    pub attributes: JSPropertyAttributes,
}
impl Default for JSStaticValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "@struct JSStaticFunction\n@abstract This structure describes a statically declared function property.\n@field name A null-terminated UTF8 string containing the property's name.\n@field callAsFunction A JSObjectCallAsFunctionCallback to invoke when the property is called as a function.\n@field attributes A logically ORed set of JSPropertyAttributes to give to the property."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSStaticFunction {
    pub name: *const ::std::os::raw::c_char,
    pub callAsFunction: JSObjectCallAsFunctionCallback,
    pub attributes: JSPropertyAttributes,
}
impl Default for JSStaticFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "@struct JSClassDefinition\n@abstract This structure contains properties and callbacks that define a type of object. All fields other than the version field are optional. Any pointer may be NULL.\n@field version The version number of this structure. The current version is 0.\n@field attributes A logically ORed set of JSClassAttributes to give to the class.\n@field className A null-terminated UTF8 string containing the class's name.\n@field parentClass A JSClass to set as the class's parent class. Pass NULL use the default object class.\n@field staticValues A JSStaticValue array containing the class's statically declared value properties. Pass NULL to specify no statically declared value properties. The array must be terminated by a JSStaticValue whose name field is NULL.\n@field staticFunctions A JSStaticFunction array containing the class's statically declared function properties. Pass NULL to specify no statically declared function properties. The array must be terminated by a JSStaticFunction whose name field is NULL.\n@field initialize The callback invoked when an object is first created. Use this callback to initialize the object.\n@field finalize The callback invoked when an object is finalized (prepared for garbage collection). Use this callback to release resources allocated for the object, and perform other cleanup.\n@field hasProperty The callback invoked when determining whether an object has a property. If this field is NULL, getProperty is called instead. The hasProperty callback enables optimization in cases where only a property's existence needs to be known, not its value, and computing its value is expensive.\n@field getProperty The callback invoked when getting a property's value.\n@field setProperty The callback invoked when setting a property's value.\n@field deleteProperty The callback invoked when deleting a property.\n@field getPropertyNames The callback invoked when collecting the names of an object's properties.\n@field callAsFunction The callback invoked when an object is called as a function.\n@field hasInstance The callback invoked when an object is used as the target of an 'instanceof' expression.\n@field callAsConstructor The callback invoked when an object is used as a constructor in a 'new' expression.\n@field convertToType The callback invoked when converting an object to a particular JavaScript type.\n@discussion The staticValues and staticFunctions arrays are the simplest and most efficient means for vending custom properties. Statically declared properties autmatically service requests like getProperty, setProperty, and getPropertyNames. Property access callbacks are required only to implement unusual properties, like array indexes, whose names are not known at compile-time.\n\nIf you named your getter function \"GetX\" and your setter function \"SetX\", you would declare a JSStaticValue array containing \"X\" like this:\n\nJSStaticValue StaticValueArray[] = {\n{ \"X\", GetX, SetX, kJSPropertyAttributeNone },\n{ 0, 0, 0, 0 }\n};\n\nStandard JavaScript practice calls for storing function objects in prototypes, so they can be shared. The default JSClass created by JSClassCreate follows this idiom, instantiating objects with a shared, automatically generating prototype containing the class's function objects. The kJSClassAttributeNoAutomaticPrototype attribute specifies that a JSClass should not automatically generate such a prototype. The resulting JSClass instantiates objects with the default object prototype, and gives each instance object its own copy of the class's function objects.\n\nA NULL callback specifies that the default object callback should substitute, except in the case of hasProperty, where it specifies that getProperty should substitute.\n\nIt is not possible to use JS subclassing with objects created from a class definition that sets callAsConstructor by default. Subclassing is supported via the JSObjectMakeConstructor function, however."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSClassDefinition {
    pub version: ::std::os::raw::c_int,
    pub attributes: JSClassAttributes,
    pub className: *const ::std::os::raw::c_char,
    pub parentClass: JSClassRef,
    pub staticValues: *const JSStaticValue,
    pub staticFunctions: *const JSStaticFunction,
    pub initialize: JSObjectInitializeCallback,
    pub finalize: JSObjectFinalizeCallback,
    pub hasProperty: JSObjectHasPropertyCallback,
    pub getProperty: JSObjectGetPropertyCallback,
    pub setProperty: JSObjectSetPropertyCallback,
    pub deleteProperty: JSObjectDeletePropertyCallback,
    pub getPropertyNames: JSObjectGetPropertyNamesCallback,
    pub callAsFunction: JSObjectCallAsFunctionCallback,
    pub callAsConstructor: JSObjectCallAsConstructorCallback,
    pub hasInstance: JSObjectHasInstanceCallback,
    pub convertToType: JSObjectConvertToTypeCallback,
}
impl Default for JSClassDefinition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "@const kJSClassDefinitionEmpty\n@abstract A JSClassDefinition structure of the current version, filled with NULL pointers and having no attributes.\n@discussion Use this constant as a convenience when creating class definitions. For example, to create a class definition with only a finalize method:\n\nJSClassDefinition definition = kJSClassDefinitionEmpty;\ndefinition.finalize = Finalize;"]
    pub static kJSClassDefinitionEmpty: JSClassDefinition;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript class suitable for use with JSObjectMake.\n@param definition A JSClassDefinition that defines the class.\n@result A JSClass with the given definition. Ownership follows the Create Rule."]
    pub fn JSClassCreate(definition: *const JSClassDefinition) -> JSClassRef;
}
extern "C" {
    #[doc = "@function\n@abstract Retains a JavaScript class.\n@param jsClass The JSClass to retain.\n@result A JSClass that is the same as jsClass."]
    pub fn JSClassRetain(jsClass: JSClassRef) -> JSClassRef;
}
extern "C" {
    #[doc = "@function\n@abstract Releases a JavaScript class.\n@param jsClass The JSClass to release."]
    pub fn JSClassRelease(jsClass: JSClassRef);
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript object.\n@param ctx The execution context to use.\n@param jsClass The JSClass to assign to the object. Pass NULL to use the default object class.\n@param data A void* to set as the object's private data. Pass NULL to specify no private data.\n@result A JSObject with the given class and private data.\n@discussion The default object class does not allocate storage for private data, so you must provide a non-NULL jsClass to JSObjectMake if you want your object to be able to store private data.\n\ndata is set on the created object before the intialize methods in its class chain are called. This enables the initialize methods to retrieve and manipulate data through JSObjectGetPrivate."]
    pub fn JSObjectMake(
        ctx: JSContextRef,
        jsClass: JSClassRef,
        data: *mut ::std::os::raw::c_void,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Convenience method for creating a JavaScript function with a given callback as its implementation.\n@param ctx The execution context to use.\n@param name A JSString containing the function's name. This will be used when converting the function to string. Pass NULL to create an anonymous function.\n@param callAsFunction The JSObjectCallAsFunctionCallback to invoke when the function is called.\n@result A JSObject that is a function. The object's prototype will be the default function prototype."]
    pub fn JSObjectMakeFunctionWithCallback(
        ctx: JSContextRef,
        name: JSStringRef,
        callAsFunction: JSObjectCallAsFunctionCallback,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Convenience method for creating a JavaScript constructor.\n@param ctx The execution context to use.\n@param jsClass A JSClass that is the class your constructor will assign to the objects its constructs. jsClass will be used to set the constructor's .prototype property, and to evaluate 'instanceof' expressions. Pass NULL to use the default object class.\n@param callAsConstructor A JSObjectCallAsConstructorCallback to invoke when your constructor is used in a 'new' expression. Pass NULL to use the default object constructor.\n@result A JSObject that is a constructor. The object's prototype will be the default object prototype.\n@discussion The default object constructor takes no arguments and constructs an object of class jsClass with no private data. If the constructor is inherited via JS subclassing and the value returned from callAsConstructor was created with jsClass, then the returned object will have it's prototype overridden to the derived class's prototype."]
    pub fn JSObjectMakeConstructor(
        ctx: JSContextRef,
        jsClass: JSClassRef,
        callAsConstructor: JSObjectCallAsConstructorCallback,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript Array object.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of data to populate the Array with. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is an Array.\n@discussion The behavior of this function does not exactly match the behavior of the built-in Array constructor. Specifically, if one argument\nis supplied, this function returns an array with one element."]
    pub fn JSObjectMakeArray(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript Date object, as if by invoking the built-in Date constructor.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the Date Constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is a Date."]
    pub fn JSObjectMakeDate(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript Error object, as if by invoking the built-in Error constructor.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the Error Constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is an Error."]
    pub fn JSObjectMakeError(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript RegExp object, as if by invoking the built-in RegExp constructor.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the RegExp Constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is a RegExp."]
    pub fn JSObjectMakeRegExp(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript promise object by invoking the provided executor.\n@param ctx The execution context to use.\n@param resolve A pointer to a JSObjectRef in which to store the resolve function for the new promise. Pass NULL if you do not care to store the resolve callback.\n@param reject A pointer to a JSObjectRef in which to store the reject function for the new promise. Pass NULL if you do not care to store the reject callback.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is a promise or NULL if an exception occurred."]
    pub fn JSObjectMakeDeferredPromise(
        ctx: JSContextRef,
        resolve: *mut JSObjectRef,
        reject: *mut JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a function with a given script as its body.\n@param ctx The execution context to use.\n@param name A JSString containing the function's name. This will be used when converting the function to string. Pass NULL to create an anonymous function.\n@param parameterCount An integer count of the number of parameter names in parameterNames.\n@param parameterNames A JSString array containing the names of the function's parameters. Pass NULL if parameterCount is 0.\n@param body A JSString containing the script to use as the function's body.\n@param sourceURL A JSString containing a URL for the script's source file. This is only used when reporting exceptions. Pass NULL if you do not care to include source file information in exceptions.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store a syntax error exception, if any. Pass NULL if you do not care to store a syntax error exception.\n@result A JSObject that is a function, or NULL if either body or parameterNames contains a syntax error. The object's prototype will be the default function prototype.\n@discussion Use this method when you want to execute a script repeatedly, to avoid the cost of re-parsing the script before each execution."]
    pub fn JSObjectMakeFunction(
        ctx: JSContextRef,
        name: JSStringRef,
        parameterCount: ::std::os::raw::c_uint,
        parameterNames: *const JSStringRef,
        body: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets an object's prototype.\n@param ctx  The execution context to use.\n@param object A JSObject whose prototype you want to get.\n@result A JSValue that is the object's prototype."]
    pub fn JSObjectGetPrototype(ctx: JSContextRef, object: JSObjectRef) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets an object's prototype.\n@param ctx  The execution context to use.\n@param object The JSObject whose prototype you want to set.\n@param value A JSValue to set as the object's prototype."]
    pub fn JSObjectSetPrototype(ctx: JSContextRef, object: JSObjectRef, value: JSValueRef);
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether an object has a given property.\n@param object The JSObject to test.\n@param propertyName A JSString containing the property's name.\n@result true if the object has a property whose name matches propertyName, otherwise false."]
    pub fn JSObjectHasProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Gets a property from an object.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to get.\n@param propertyName A JSString containing the property's name.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The property's value if object has the property, otherwise the undefined value."]
    pub fn JSObjectGetProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets a property on an object.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to set.\n@param propertyName A JSString containing the property's name.\n@param value A JSValueRef to use as the property's value.\n@param attributes A logically ORed set of JSPropertyAttributes to give to the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception."]
    pub fn JSObjectSetProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Deletes a property from an object.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to delete.\n@param propertyName A JSString containing the property's name.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the delete operation succeeds, otherwise false (for example, if the property has the kJSPropertyAttributeDontDelete attribute set)."]
    pub fn JSObjectDeleteProperty(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether an object has a given property using a JSValueRef as the property key.\n@param object The JSObject to test.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the object has a property whose name matches propertyKey, otherwise false.\n@discussion This function is the same as performing \"propertyKey in object\" from JavaScript."]
    pub fn JSObjectHasPropertyForKey(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Gets a property from an object using a JSValueRef as the property key.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to get.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The property's value if object has the property key, otherwise the undefined value.\n@discussion This function is the same as performing \"object[propertyKey]\" from JavaScript."]
    pub fn JSObjectGetPropertyForKey(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets a property on an object using a JSValueRef as the property key.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to set.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param value A JSValueRef to use as the property's value.\n@param attributes A logically ORed set of JSPropertyAttributes to give to the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@discussion This function is the same as performing \"object[propertyKey] = value\" from JavaScript."]
    pub fn JSObjectSetPropertyForKey(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Deletes a property from an object using a JSValueRef as the property key.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to delete.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the delete operation succeeds, otherwise false (for example, if the property has the kJSPropertyAttributeDontDelete attribute set).\n@discussion This function is the same as performing \"delete object[propertyKey]\" from JavaScript."]
    pub fn JSObjectDeletePropertyForKey(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Gets a property from an object by numeric index.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to get.\n@param propertyIndex An integer value that is the property's name.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The property's value if object has the property, otherwise the undefined value.\n@discussion Calling JSObjectGetPropertyAtIndex is equivalent to calling JSObjectGetProperty with a string containing propertyIndex, but JSObjectGetPropertyAtIndex provides optimized access to numeric properties."]
    pub fn JSObjectGetPropertyAtIndex(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets a property on an object by numeric index.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to set.\n@param propertyIndex The property's name as a number.\n@param value A JSValue to use as the property's value.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@discussion Calling JSObjectSetPropertyAtIndex is equivalent to calling JSObjectSetProperty with a string containing propertyIndex, but JSObjectSetPropertyAtIndex provides optimized access to numeric properties."]
    pub fn JSObjectSetPropertyAtIndex(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        value: JSValueRef,
        exception: *mut JSValueRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Gets an object's private data.\n@param object A JSObject whose private data you want to get.\n@result A void* that is the object's private data, if the object has private data, otherwise NULL."]
    pub fn JSObjectGetPrivate(object: JSObjectRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function\n@abstract Sets a pointer to private data on an object.\n@param object The JSObject whose private data you want to set.\n@param data A void* to set as the object's private data.\n@result true if object can store private data, otherwise false.\n@discussion The default object class does not allocate storage for private data. Only objects created with a non-NULL JSClass can store private data."]
    pub fn JSObjectSetPrivate(object: JSObjectRef, data: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether an object can be called as a function.\n@param ctx  The execution context to use.\n@param object The JSObject to test.\n@result true if the object can be called as a function, otherwise false."]
    pub fn JSObjectIsFunction(ctx: JSContextRef, object: JSObjectRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Calls an object as a function.\n@param ctx The execution context to use.\n@param object The JSObject to call as a function.\n@param thisObject The object to use as \"this,\" or NULL to use the global object as \"this.\"\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the function. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The JSValue that results from calling object as a function, or NULL if an exception is thrown or object is not a function."]
    pub fn JSObjectCallAsFunction(
        ctx: JSContextRef,
        object: JSObjectRef,
        thisObject: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}
extern "C" {
    #[doc = "@function\n@abstract Tests whether an object can be called as a constructor.\n@param ctx  The execution context to use.\n@param object The JSObject to test.\n@result true if the object can be called as a constructor, otherwise false."]
    pub fn JSObjectIsConstructor(ctx: JSContextRef, object: JSObjectRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Calls an object as a constructor.\n@param ctx The execution context to use.\n@param object The JSObject to call as a constructor.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The JSObject that results from calling object as a constructor, or NULL if an exception is thrown or object is not a constructor."]
    pub fn JSObjectCallAsConstructor(
        ctx: JSContextRef,
        object: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets the names of an object's enumerable properties.\n@param ctx The execution context to use.\n@param object The object whose property names you want to get.\n@result A JSPropertyNameArray containing the names object's enumerable properties. Ownership follows the Create Rule."]
    pub fn JSObjectCopyPropertyNames(
        ctx: JSContextRef,
        object: JSObjectRef,
    ) -> JSPropertyNameArrayRef;
}
extern "C" {
    #[doc = "@function\n@abstract Retains a JavaScript property name array.\n@param array The JSPropertyNameArray to retain.\n@result A JSPropertyNameArray that is the same as array."]
    pub fn JSPropertyNameArrayRetain(array: JSPropertyNameArrayRef) -> JSPropertyNameArrayRef;
}
extern "C" {
    #[doc = "@function\n@abstract Releases a JavaScript property name array.\n@param array The JSPropetyNameArray to release."]
    pub fn JSPropertyNameArrayRelease(array: JSPropertyNameArrayRef);
}
extern "C" {
    #[doc = "@function\n@abstract Gets a count of the number of items in a JavaScript property name array.\n@param array The array from which to retrieve the count.\n@result An integer count of the number of names in array."]
    pub fn JSPropertyNameArrayGetCount(array: JSPropertyNameArrayRef) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract Gets a property name at a given index in a JavaScript property name array.\n@param array The array from which to retrieve the property name.\n@param index The index of the property name to retrieve.\n@result A JSStringRef containing the property name."]
    pub fn JSPropertyNameArrayGetNameAtIndex(
        array: JSPropertyNameArrayRef,
        index: usize,
    ) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract Adds a property name to a JavaScript property name accumulator.\n@param accumulator The accumulator object to which to add the property name.\n@param propertyName The property name to add."]
    pub fn JSPropertyNameAccumulatorAddName(
        accumulator: JSPropertyNameAccumulatorRef,
        propertyName: JSStringRef,
    );
}
extern "C" {
    #[doc = "@function\n@abstract Creates a JavaScript context group.\n@discussion A JSContextGroup associates JavaScript contexts with one another.\nContexts in the same group may share and exchange JavaScript objects. Sharing and/or exchanging\nJavaScript objects between contexts in different groups will produce undefined behavior.\nWhen objects from the same context group are used in multiple threads, explicit\nsynchronization is required.\n\nA JSContextGroup may need to run deferred tasks on a run loop, such as garbage collection\nor resolving WebAssembly compilations. By default, calling JSContextGroupCreate will use\nthe run loop of the thread it was called on. Currently, there is no API to change a\nJSContextGroup's run loop once it has been created.\n@result The created JSContextGroup."]
    pub fn JSContextGroupCreate() -> JSContextGroupRef;
}
extern "C" {
    #[doc = "@function\n@abstract Retains a JavaScript context group.\n@param group The JSContextGroup to retain.\n@result A JSContextGroup that is the same as group."]
    pub fn JSContextGroupRetain(group: JSContextGroupRef) -> JSContextGroupRef;
}
extern "C" {
    #[doc = "@function\n@abstract Releases a JavaScript context group.\n@param group The JSContextGroup to release."]
    pub fn JSContextGroupRelease(group: JSContextGroupRef);
}
extern "C" {
    #[doc = "@function\n@abstract Creates a global JavaScript execution context.\n@discussion JSGlobalContextCreate allocates a global object and populates it with all the\nbuilt-in JavaScript objects, such as Object, Function, String, and Array.\n\nIn WebKit version 4.0 and later, the context is created in a unique context group.\nTherefore, scripts may execute in it concurrently with scripts executing in other contexts.\nHowever, you may not use values created in the context in other contexts.\n@param globalObjectClass The class to use when creating the global object. Pass\nNULL to use the default object class.\n@result A JSGlobalContext with a global object of class globalObjectClass."]
    pub fn JSGlobalContextCreate(globalObjectClass: JSClassRef) -> JSGlobalContextRef;
}
extern "C" {
    #[doc = "@function\n@abstract Creates a global JavaScript execution context in the context group provided.\n@discussion JSGlobalContextCreateInGroup allocates a global object and populates it with\nall the built-in JavaScript objects, such as Object, Function, String, and Array.\n@param globalObjectClass The class to use when creating the global object. Pass\nNULL to use the default object class.\n@param group The context group to use. The created global context retains the group.\nPass NULL to create a unique group for the context.\n@result A JSGlobalContext with a global object of class globalObjectClass and a context\ngroup equal to group."]
    pub fn JSGlobalContextCreateInGroup(
        group: JSContextGroupRef,
        globalObjectClass: JSClassRef,
    ) -> JSGlobalContextRef;
}
extern "C" {
    #[doc = "@function\n@abstract Retains a global JavaScript execution context.\n@param ctx The JSGlobalContext to retain.\n@result A JSGlobalContext that is the same as ctx."]
    pub fn JSGlobalContextRetain(ctx: JSGlobalContextRef) -> JSGlobalContextRef;
}
extern "C" {
    #[doc = "@function\n@abstract Releases a global JavaScript execution context.\n@param ctx The JSGlobalContext to release."]
    pub fn JSGlobalContextRelease(ctx: JSGlobalContextRef);
}
extern "C" {
    #[doc = "@function\n@abstract Gets the global object of a JavaScript execution context.\n@param ctx The JSContext whose global object you want to get.\n@result ctx's global object."]
    pub fn JSContextGetGlobalObject(ctx: JSContextRef) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets the context group to which a JavaScript execution context belongs.\n@param ctx The JSContext whose group you want to get.\n@result ctx's group."]
    pub fn JSContextGetGroup(ctx: JSContextRef) -> JSContextGroupRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets the global context of a JavaScript execution context.\n@param ctx The JSContext whose global context you want to get.\n@result ctx's global context."]
    pub fn JSContextGetGlobalContext(ctx: JSContextRef) -> JSGlobalContextRef;
}
extern "C" {
    #[doc = "@function\n@abstract Gets a copy of the name of a context.\n@param ctx The JSGlobalContext whose name you want to get.\n@result The name for ctx.\n@discussion A JSGlobalContext's name is exposed when inspecting the context to make it easier to identify the context you would like to inspect."]
    pub fn JSGlobalContextCopyName(ctx: JSGlobalContextRef) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract Sets the name exposed when inspecting a context.\n@param ctx The JSGlobalContext that you want to name.\n@param name The name to set on the context."]
    pub fn JSGlobalContextSetName(ctx: JSGlobalContextRef, name: JSStringRef);
}
extern "C" {
    #[doc = "@function\n@abstract Gets whether the context is inspectable in Web Inspector.\n@param ctx The JSGlobalContext that you want to change the inspectability of.\n@result Whether the context is inspectable in Web Inspector."]
    pub fn JSGlobalContextIsInspectable(ctx: JSGlobalContextRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract Sets whether the context is inspectable in Web Inspector. Default value is NO.\n@param ctx The JSGlobalContext that you want to change the inspectability of.\n@param inspectable YES to allow Web Inspector to connect to the context, otherwise NO."]
    pub fn JSGlobalContextSetInspectable(ctx: JSGlobalContextRef, inspectable: bool);
}
pub type JSChar = wchar_t;
extern "C" {
    #[doc = "@function\n@abstract         Creates a JavaScript string from a buffer of Unicode characters.\n@param chars      The buffer of Unicode characters to copy into the new JSString.\n@param numChars   The number of characters to copy from the buffer pointed to by chars.\n@result           A JSString containing chars. Ownership follows the Create Rule."]
    pub fn JSStringCreateWithCharacters(chars: *const JSChar, numChars: usize) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract         Creates a JavaScript string from a null-terminated UTF8 string.\n@param string     The null-terminated UTF8 string to copy into the new JSString.\n@result           A JSString containing string. Ownership follows the Create Rule."]
    pub fn JSStringCreateWithUTF8CString(string: *const ::std::os::raw::c_char) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract         Retains a JavaScript string.\n@param string     The JSString to retain.\n@result           A JSString that is the same as string."]
    pub fn JSStringRetain(string: JSStringRef) -> JSStringRef;
}
extern "C" {
    #[doc = "@function\n@abstract         Releases a JavaScript string.\n@param string     The JSString to release."]
    pub fn JSStringRelease(string: JSStringRef);
}
extern "C" {
    #[doc = "@function\n@abstract         Returns the number of Unicode characters in a JavaScript string.\n@param string     The JSString whose length (in Unicode characters) you want to know.\n@result           The number of Unicode characters stored in string."]
    pub fn JSStringGetLength(string: JSStringRef) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract         Returns a pointer to the Unicode character buffer that\nserves as the backing store for a JavaScript string.\n@param string     The JSString whose backing store you want to access.\n@result           A pointer to the Unicode character buffer that serves as string's\nbacking store, which will be deallocated when string is deallocated."]
    pub fn JSStringGetCharactersPtr(string: JSStringRef) -> *const JSChar;
}
extern "C" {
    #[doc = "@function\n@abstract Returns the maximum number of bytes a JavaScript string will\ntake up if converted into a null-terminated UTF8 string.\n@param string The JSString whose maximum converted size (in bytes) you\nwant to know.\n@result The maximum number of bytes that could be required to convert string into a\nnull-terminated UTF8 string. The number of bytes that the conversion actually ends\nup requiring could be less than this, but never more."]
    pub fn JSStringGetMaximumUTF8CStringSize(string: JSStringRef) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract Converts a JavaScript string into a null-terminated UTF8 string,\nand copies the result into an external byte buffer.\n@param string The source JSString.\n@param buffer The destination byte buffer into which to copy a null-terminated\nUTF8 representation of string. On return, buffer contains a UTF8 string\nrepresentation of string. If bufferSize is too small, buffer will contain only\npartial results. If buffer is not at least bufferSize bytes in size,\nbehavior is undefined.\n@param bufferSize The size of the external buffer in bytes.\n@result The number of bytes written into buffer (including the null-terminator byte)."]
    pub fn JSStringGetUTF8CString(
        string: JSStringRef,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract     Tests whether two JavaScript strings match.\n@param a      The first JSString to test.\n@param b      The second JSString to test.\n@result       true if the two strings match, otherwise false."]
    pub fn JSStringIsEqual(a: JSStringRef, b: JSStringRef) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract     Tests whether a JavaScript string matches a null-terminated UTF8 string.\n@param a      The JSString to test.\n@param b      The null-terminated UTF8 string to test.\n@result       true if the two strings match, otherwise false."]
    pub fn JSStringIsEqualToUTF8CString(a: JSStringRef, b: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = "@function\n@abstract           Creates a JavaScript Typed Array object with the given number of elements.\n@param ctx          The execution context to use.\n@param arrayType    A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param length       The number of elements to be in the new Typed Array.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef that is a Typed Array with all elements set to zero or NULL if there was an error."]
    pub fn JSObjectMakeTypedArray(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract                 Creates a JavaScript Typed Array object from an existing pointer.\n@param ctx                The execution context to use.\n@param arrayType          A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param bytes              A pointer to the byte buffer to be used as the backing store of the Typed Array object.\n@param byteLength         The number of bytes pointed to by the parameter bytes.\n@param bytesDeallocator   The allocator to use to deallocate the external buffer when the JSTypedArrayData object is deallocated.\n@param deallocatorContext A pointer to pass back to the deallocator.\n@param exception          A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result                   A JSObjectRef Typed Array whose backing store is the same as the one pointed to by bytes or NULL if there was an error.\n@discussion               If an exception is thrown during this function the bytesDeallocator will always be called."]
    pub fn JSObjectMakeTypedArrayWithBytesNoCopy(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract           Creates a JavaScript Typed Array object from an existing JavaScript Array Buffer object.\n@param ctx          The execution context to use.\n@param arrayType    A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param buffer       An Array Buffer object that should be used as the backing store for the created JavaScript Typed Array object.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef that is a Typed Array or NULL if there was an error. The backing store of the Typed Array will be buffer."]
    pub fn JSObjectMakeTypedArrayWithArrayBuffer(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract           Creates a JavaScript Typed Array object from an existing JavaScript Array Buffer object with the given offset and length.\n@param ctx          The execution context to use.\n@param arrayType    A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param buffer       An Array Buffer object that should be used as the backing store for the created JavaScript Typed Array object.\n@param byteOffset   The byte offset for the created Typed Array. byteOffset should aligned with the element size of arrayType.\n@param length       The number of elements to include in the Typed Array.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef that is a Typed Array or NULL if there was an error. The backing store of the Typed Array will be buffer."]
    pub fn JSObjectMakeTypedArrayWithArrayBufferAndOffset(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        byteOffset: usize,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns a temporary pointer to the backing store of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose backing store pointer to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A pointer to the raw data buffer that serves as object's backing store or NULL if object is not a Typed Array object.\n@discussion         The pointer returned by this function is temporary and is not guaranteed to remain valid across JavaScriptCore API calls."]
    pub fn JSObjectGetTypedArrayBytesPtr(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns the length of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose length to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             The length of the Typed Array object or 0 if the object is not a Typed Array object."]
    pub fn JSObjectGetTypedArrayLength(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns the byte length of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose byte length to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             The byte length of the Typed Array object or 0 if the object is not a Typed Array object."]
    pub fn JSObjectGetTypedArrayByteLength(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns the byte offset of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose byte offset to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             The byte offset of the Typed Array object or 0 if the object is not a Typed Array object."]
    pub fn JSObjectGetTypedArrayByteOffset(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
extern "C" {
    #[doc = "@function\n@abstract           Returns the JavaScript Array Buffer object that is used as the backing of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The JSObjectRef whose Typed Array type data pointer to obtain.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef with a JSTypedArrayType of kJSTypedArrayTypeArrayBuffer or NULL if object is not a Typed Array."]
    pub fn JSObjectGetTypedArrayBuffer(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract                 Creates a JavaScript Array Buffer object from an existing pointer.\n@param ctx                The execution context to use.\n@param bytes              A pointer to the byte buffer to be used as the backing store of the Typed Array object.\n@param byteLength         The number of bytes pointed to by the parameter bytes.\n@param bytesDeallocator   The allocator to use to deallocate the external buffer when the Typed Array data object is deallocated.\n@param deallocatorContext A pointer to pass back to the deallocator.\n@param exception          A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result                   A JSObjectRef Array Buffer whose backing store is the same as the one pointed to by bytes or NULL if there was an error.\n@discussion               If an exception is thrown during this function the bytesDeallocator will always be called."]
    pub fn JSObjectMakeArrayBufferWithBytesNoCopy(
        ctx: JSContextRef,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}
extern "C" {
    #[doc = "@function\n@abstract         Returns a pointer to the data buffer that serves as the backing store for a JavaScript Typed Array object.\n@param object     The Array Buffer object whose internal backing store pointer to return.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result           A pointer to the raw data buffer that serves as object's backing store or NULL if object is not an Array Buffer object.\n@discussion       The pointer returned by this function is temporary and is not guaranteed to remain valid across JavaScriptCore API calls."]
    pub fn JSObjectGetArrayBufferBytesPtr(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@function\n@abstract         Returns the number of bytes in a JavaScript data object.\n@param ctx        The execution context to use.\n@param object     The JS Arary Buffer object whose length in bytes to return.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result           The number of bytes stored in the data object."]
    pub fn JSObjectGetArrayBufferByteLength(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize;
}
pub type ULChar16 = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Config {
    _unused: [u8; 0],
}
pub type ULConfig = *mut C_Config;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Renderer {
    _unused: [u8; 0],
}
pub type ULRenderer = *mut C_Renderer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Session {
    _unused: [u8; 0],
}
pub type ULSession = *mut C_Session;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_ViewConfig {
    _unused: [u8; 0],
}
pub type ULViewConfig = *mut C_ViewConfig;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_View {
    _unused: [u8; 0],
}
pub type ULView = *mut C_View;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Bitmap {
    _unused: [u8; 0],
}
pub type ULBitmap = *mut C_Bitmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_String {
    _unused: [u8; 0],
}
pub type ULString = *mut C_String;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Buffer {
    _unused: [u8; 0],
}
pub type ULBuffer = *mut C_Buffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_KeyEvent {
    _unused: [u8; 0],
}
pub type ULKeyEvent = *mut C_KeyEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_MouseEvent {
    _unused: [u8; 0],
}
pub type ULMouseEvent = *mut C_MouseEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_ScrollEvent {
    _unused: [u8; 0],
}
pub type ULScrollEvent = *mut C_ScrollEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_GamepadEvent {
    _unused: [u8; 0],
}
pub type ULGamepadEvent = *mut C_GamepadEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_GamepadAxisEvent {
    _unused: [u8; 0],
}
pub type ULGamepadAxisEvent = *mut C_GamepadAxisEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_GamepadButtonEvent {
    _unused: [u8; 0],
}
pub type ULGamepadButtonEvent = *mut C_GamepadButtonEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Surface {
    _unused: [u8; 0],
}
pub type ULSurface = *mut C_Surface;
pub type ULBitmapSurface = *mut C_Surface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_FontFile {
    _unused: [u8; 0],
}
pub type ULFontFile = *mut C_FontFile;
pub const ULMessageSource_kMessageSource_XML: ULMessageSource = 0;
pub const ULMessageSource_kMessageSource_JS: ULMessageSource = 1;
pub const ULMessageSource_kMessageSource_Network: ULMessageSource = 2;
pub const ULMessageSource_kMessageSource_ConsoleAPI: ULMessageSource = 3;
pub const ULMessageSource_kMessageSource_Storage: ULMessageSource = 4;
pub const ULMessageSource_kMessageSource_AppCache: ULMessageSource = 5;
pub const ULMessageSource_kMessageSource_Rendering: ULMessageSource = 6;
pub const ULMessageSource_kMessageSource_CSS: ULMessageSource = 7;
pub const ULMessageSource_kMessageSource_Security: ULMessageSource = 8;
pub const ULMessageSource_kMessageSource_ContentBlocker: ULMessageSource = 9;
pub const ULMessageSource_kMessageSource_Other: ULMessageSource = 10;
pub type ULMessageSource = ::std::os::raw::c_int;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ULMessageLevel {
    kMessageLevel_Log = 1,
    kMessageLevel_Warning = 2,
    kMessageLevel_Error = 3,
    kMessageLevel_Debug = 4,
    kMessageLevel_Info = 5,
}
pub const ULCursor_kCursor_Pointer: ULCursor = 0;
pub const ULCursor_kCursor_Cross: ULCursor = 1;
pub const ULCursor_kCursor_Hand: ULCursor = 2;
pub const ULCursor_kCursor_IBeam: ULCursor = 3;
pub const ULCursor_kCursor_Wait: ULCursor = 4;
pub const ULCursor_kCursor_Help: ULCursor = 5;
pub const ULCursor_kCursor_EastResize: ULCursor = 6;
pub const ULCursor_kCursor_NorthResize: ULCursor = 7;
pub const ULCursor_kCursor_NorthEastResize: ULCursor = 8;
pub const ULCursor_kCursor_NorthWestResize: ULCursor = 9;
pub const ULCursor_kCursor_SouthResize: ULCursor = 10;
pub const ULCursor_kCursor_SouthEastResize: ULCursor = 11;
pub const ULCursor_kCursor_SouthWestResize: ULCursor = 12;
pub const ULCursor_kCursor_WestResize: ULCursor = 13;
pub const ULCursor_kCursor_NorthSouthResize: ULCursor = 14;
pub const ULCursor_kCursor_EastWestResize: ULCursor = 15;
pub const ULCursor_kCursor_NorthEastSouthWestResize: ULCursor = 16;
pub const ULCursor_kCursor_NorthWestSouthEastResize: ULCursor = 17;
pub const ULCursor_kCursor_ColumnResize: ULCursor = 18;
pub const ULCursor_kCursor_RowResize: ULCursor = 19;
pub const ULCursor_kCursor_MiddlePanning: ULCursor = 20;
pub const ULCursor_kCursor_EastPanning: ULCursor = 21;
pub const ULCursor_kCursor_NorthPanning: ULCursor = 22;
pub const ULCursor_kCursor_NorthEastPanning: ULCursor = 23;
pub const ULCursor_kCursor_NorthWestPanning: ULCursor = 24;
pub const ULCursor_kCursor_SouthPanning: ULCursor = 25;
pub const ULCursor_kCursor_SouthEastPanning: ULCursor = 26;
pub const ULCursor_kCursor_SouthWestPanning: ULCursor = 27;
pub const ULCursor_kCursor_WestPanning: ULCursor = 28;
pub const ULCursor_kCursor_Move: ULCursor = 29;
pub const ULCursor_kCursor_VerticalText: ULCursor = 30;
pub const ULCursor_kCursor_Cell: ULCursor = 31;
pub const ULCursor_kCursor_ContextMenu: ULCursor = 32;
pub const ULCursor_kCursor_Alias: ULCursor = 33;
pub const ULCursor_kCursor_Progress: ULCursor = 34;
pub const ULCursor_kCursor_NoDrop: ULCursor = 35;
pub const ULCursor_kCursor_Copy: ULCursor = 36;
pub const ULCursor_kCursor_None: ULCursor = 37;
pub const ULCursor_kCursor_NotAllowed: ULCursor = 38;
pub const ULCursor_kCursor_ZoomIn: ULCursor = 39;
pub const ULCursor_kCursor_ZoomOut: ULCursor = 40;
pub const ULCursor_kCursor_Grab: ULCursor = 41;
pub const ULCursor_kCursor_Grabbing: ULCursor = 42;
pub const ULCursor_kCursor_Custom: ULCursor = 43;
pub type ULCursor = ::std::os::raw::c_int;
#[doc = "\n Alpha channel only, 8-bits per pixel.\n\n Encoding: 8-bits per channel, unsigned normalized.\n\n Color-space: Linear (no gamma), alpha-coverage only.\n"]
pub const ULBitmapFormat_kBitmapFormat_A8_UNORM: ULBitmapFormat = 0;
#[doc = "\n Blue Green Red Alpha channels, 32-bits per pixel.\n\n Encoding: 8-bits per channel, unsigned normalized.\n\n Color-space: sRGB gamma with premultiplied linear alpha channel.\n"]
pub const ULBitmapFormat_kBitmapFormat_BGRA8_UNORM_SRGB: ULBitmapFormat = 1;
pub type ULBitmapFormat = ::std::os::raw::c_int;
#[doc = "\n Key-Down event type. (Does not trigger accelerator commands in WebCore)\n\n @NOTE: You should probably use RawKeyDown instead when a physical key\n        is pressed. This member is only here for historic compatibility\n        with WebCore's key event types.\n"]
pub const ULKeyEventType_kKeyEventType_KeyDown: ULKeyEventType = 0;
#[doc = "\n Key-Up event type. Use this when a physical key is released.\n"]
pub const ULKeyEventType_kKeyEventType_KeyUp: ULKeyEventType = 1;
#[doc = "\n Raw Key-Down type. Use this when a physical key is pressed.\n\n @NOTE: You should use RawKeyDown for physical key presses since it\n        allows WebCore to do additional command translation.\n"]
pub const ULKeyEventType_kKeyEventType_RawKeyDown: ULKeyEventType = 2;
#[doc = "\n Character input event type. Use this when the OS generates text from\n a physical key being pressed (eg, WM_CHAR on Windows).\n"]
pub const ULKeyEventType_kKeyEventType_Char: ULKeyEventType = 3;
pub type ULKeyEventType = ::std::os::raw::c_int;
pub const ULMouseEventType_kMouseEventType_MouseMoved: ULMouseEventType = 0;
pub const ULMouseEventType_kMouseEventType_MouseDown: ULMouseEventType = 1;
pub const ULMouseEventType_kMouseEventType_MouseUp: ULMouseEventType = 2;
pub type ULMouseEventType = ::std::os::raw::c_int;
pub const ULMouseButton_kMouseButton_None: ULMouseButton = 0;
pub const ULMouseButton_kMouseButton_Left: ULMouseButton = 1;
pub const ULMouseButton_kMouseButton_Middle: ULMouseButton = 2;
pub const ULMouseButton_kMouseButton_Right: ULMouseButton = 3;
pub type ULMouseButton = ::std::os::raw::c_int;
pub const ULScrollEventType_kScrollEventType_ScrollByPixel: ULScrollEventType = 0;
pub const ULScrollEventType_kScrollEventType_ScrollByPage: ULScrollEventType = 1;
pub type ULScrollEventType = ::std::os::raw::c_int;
pub const ULGamepadEventType_kGamepadEventType_Connected: ULGamepadEventType = 0;
pub const ULGamepadEventType_kGamepadEventType_Disconnected: ULGamepadEventType = 1;
pub type ULGamepadEventType = ::std::os::raw::c_int;
pub const ULFaceWinding_kFaceWinding_Clockwise: ULFaceWinding = 0;
pub const ULFaceWinding_kFaceWinding_CounterClockwise: ULFaceWinding = 1;
pub type ULFaceWinding = ::std::os::raw::c_int;
#[doc = "\n Lighter hinting algorithm-- glyphs are slightly fuzzier but better\n resemble their original shape. This is achieved by snapping glyphs to the\n pixel grid only vertically which better preserves inter-glyph spacing.\n"]
pub const ULFontHinting_kFontHinting_Smooth: ULFontHinting = 0;
#[doc = "\n Default hinting algorithm-- offers a good balance between sharpness and\n shape at smaller font sizes.\n"]
pub const ULFontHinting_kFontHinting_Normal: ULFontHinting = 1;
#[doc = "\n Strongest hinting algorithm-- outputs only black/white glyphs. The result\n is usually unpleasant if the underlying TTF does not contain hints for\n this type of rendering.\n"]
pub const ULFontHinting_kFontHinting_Monochrome: ULFontHinting = 2;
pub type ULFontHinting = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULRect {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULIntRect {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULRenderTarget {
    pub is_empty: bool,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub texture_id: ::std::os::raw::c_uint,
    pub texture_width: ::std::os::raw::c_uint,
    pub texture_height: ::std::os::raw::c_uint,
    pub texture_format: ULBitmapFormat,
    pub uv_coords: ULRect,
    pub render_buffer_id: ::std::os::raw::c_uint,
}
impl Default for ULRenderTarget {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "\n Get the version string of the library in MAJOR.MINOR.PATCH format.\n"]
    pub fn ulVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n Get the numeric major version of the library.\n"]
    pub fn ulVersionMajor() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the numeric minor version of the library.\n"]
    pub fn ulVersionMinor() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the numeric patch version of the library.\n"]
    pub fn ulVersionPatch() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the full WebKit version string.\n"]
    pub fn ulWebKitVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n Create empty bitmap.\n"]
    pub fn ulCreateEmptyBitmap() -> ULBitmap;
}
extern "C" {
    #[doc = "\n Create bitmap with certain dimensions and pixel format.\n"]
    pub fn ulCreateBitmap(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: ULBitmapFormat,
    ) -> ULBitmap;
}
extern "C" {
    #[doc = "\n Create bitmap from existing pixel buffer. @see Bitmap for help using this function.\n"]
    pub fn ulCreateBitmapFromPixels(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: ULBitmapFormat,
        row_bytes: ::std::os::raw::c_uint,
        pixels: *const ::std::os::raw::c_void,
        size: usize,
        should_copy: bool,
    ) -> ULBitmap;
}
extern "C" {
    #[doc = "\n Create bitmap from copy.\n"]
    pub fn ulCreateBitmapFromCopy(existing_bitmap: ULBitmap) -> ULBitmap;
}
extern "C" {
    #[doc = "\n Destroy a bitmap (you should only destroy Bitmaps you have explicitly created via one of the\n creation functions above.\n"]
    pub fn ulDestroyBitmap(bitmap: ULBitmap);
}
extern "C" {
    #[doc = "\n Get the width in pixels.\n"]
    pub fn ulBitmapGetWidth(bitmap: ULBitmap) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height in pixels.\n"]
    pub fn ulBitmapGetHeight(bitmap: ULBitmap) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the pixel format.\n"]
    pub fn ulBitmapGetFormat(bitmap: ULBitmap) -> ULBitmapFormat;
}
extern "C" {
    #[doc = "\n Get the bytes per pixel.\n"]
    pub fn ulBitmapGetBpp(bitmap: ULBitmap) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the number of bytes per row.\n"]
    pub fn ulBitmapGetRowBytes(bitmap: ULBitmap) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the size in bytes of the underlying pixel buffer.\n"]
    pub fn ulBitmapGetSize(bitmap: ULBitmap) -> usize;
}
extern "C" {
    #[doc = "\n Whether or not this bitmap owns its own pixel buffer.\n"]
    pub fn ulBitmapOwnsPixels(bitmap: ULBitmap) -> bool;
}
extern "C" {
    #[doc = "\n Lock pixels for reading/writing, returns pointer to pixel buffer.\n"]
    pub fn ulBitmapLockPixels(bitmap: ULBitmap) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Unlock pixels after locking.\n"]
    pub fn ulBitmapUnlockPixels(bitmap: ULBitmap);
}
extern "C" {
    #[doc = "\n Get raw pixel buffer-- you should only call this if Bitmap is already locked.\n"]
    pub fn ulBitmapRawPixels(bitmap: ULBitmap) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Whether or not this bitmap is empty.\n"]
    pub fn ulBitmapIsEmpty(bitmap: ULBitmap) -> bool;
}
extern "C" {
    #[doc = "\n Reset bitmap pixels to 0.\n"]
    pub fn ulBitmapErase(bitmap: ULBitmap);
}
extern "C" {
    #[doc = "\n Write bitmap to a PNG on disk.\n"]
    pub fn ulBitmapWritePNG(bitmap: ULBitmap, path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = "\n This converts a BGRA bitmap to RGBA bitmap and vice-versa by swapping the red and blue channels.\n"]
    pub fn ulBitmapSwapRedBlueChannels(bitmap: ULBitmap);
}
pub type ulDestroyBufferCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = "\n Create a Buffer from existing, user-owned data without any copies. An optional, user-supplied\n callback will be called to deallocate data upon destruction.\n\n @param  data                  A pointer to the data.\n\n @param  size                  Size of the data in bytes.\n\n @param  user_data             Optional user data that will be passed to destruction_callback\n                               when the returned Buffer is destroyed.\n\n @param  destruction_callback  Optional callback that will be called upon destruction. Pass a\n                               null pointer if you don't want to be informed of destruction.\n"]
    pub fn ulCreateBuffer(
        data: *mut ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
        destruction_callback: ulDestroyBufferCallback,
    ) -> ULBuffer;
}
extern "C" {
    #[doc = "\n Create a Buffer from existing data, a deep copy of data will be made.\n"]
    pub fn ulCreateBufferFromCopy(data: *const ::std::os::raw::c_void, size: usize) -> ULBuffer;
}
extern "C" {
    #[doc = "\n Destroy buffer (you should destroy any buffers you explicitly Create).\n"]
    pub fn ulDestroyBuffer(buffer: ULBuffer);
}
extern "C" {
    #[doc = "\n Get a pointer to the raw byte data.\n"]
    pub fn ulBufferGetData(buffer: ULBuffer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Get the size in bytes.\n"]
    pub fn ulBufferGetSize(buffer: ULBuffer) -> usize;
}
extern "C" {
    #[doc = "\n Get the user data associated with this Buffer, if any.\n"]
    pub fn ulBufferGetUserData(buffer: ULBuffer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Check whether this Buffer owns its own data (Buffer was created via ulCreateBufferFromCopy).\n If this is false, Buffer will call the user-supplied destruction callback to deallocate data\n when this Buffer instance is destroyed.\n"]
    pub fn ulBufferOwnsData(buffer: ULBuffer) -> bool;
}
#[doc = "\n The callback invoked when the library wants to clear the system's clipboard.\n"]
pub type ULClipboardClearCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "\n The callback invoked when the library wants to read from the system's clipboard.\n\n You should store the result (if any) in 'result'.\n"]
pub type ULClipboardReadPlainTextCallback =
    ::std::option::Option<unsafe extern "C" fn(result: ULString)>;
#[doc = "\n The callback invoked when the library wants to write to the system's clipboard.\n"]
pub type ULClipboardWritePlainTextCallback =
    ::std::option::Option<unsafe extern "C" fn(text: ULString)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULClipboard {
    pub clear: ULClipboardClearCallback,
    pub read_plain_text: ULClipboardReadPlainTextCallback,
    pub write_plain_text: ULClipboardWritePlainTextCallback,
}
extern "C" {
    #[doc = "\n Create config with default values (see <Ultralight/platform/Config.h>).\n"]
    pub fn ulCreateConfig() -> ULConfig;
}
extern "C" {
    #[doc = "\n Destroy config.\n"]
    pub fn ulDestroyConfig(config: ULConfig);
}
extern "C" {
    #[doc = "\n A writable OS file path to store persistent Session data in.\n\n This data may include cookies, cached network resources, indexed DB, etc.\n\n @note Files are only written to the path when using a persistent Session.\n"]
    pub fn ulConfigSetCachePath(config: ULConfig, cache_path: ULString);
}
extern "C" {
    #[doc = "\n The relative path to the resources folder (loaded via the FileSystem API).\n\n The library loads certain resources (SSL certs, ICU data, etc.) from the FileSystem API\n during runtime (eg, `file:///resources/cacert.pem`).\n\n You can customize the relative file path to the resources folder by modifying this setting.\n\n (Default = \"resources/\")\n"]
    pub fn ulConfigSetResourcePathPrefix(config: ULConfig, resource_path_prefix: ULString);
}
extern "C" {
    #[doc = "\n The winding order for front-facing triangles.\n\n @pre Only used when GPU rendering is enabled for the View.\n\n (Default = kFaceWinding_CounterClockwise)\n"]
    pub fn ulConfigSetFaceWinding(config: ULConfig, winding: ULFaceWinding);
}
extern "C" {
    #[doc = "\n The hinting algorithm to use when rendering fonts. (Default = kFontHinting_Normal)\n\n @see ULFontHinting\n"]
    pub fn ulConfigSetFontHinting(config: ULConfig, font_hinting: ULFontHinting);
}
extern "C" {
    #[doc = "\n The gamma to use when compositing font glyphs, change this value to adjust contrast (Adobe and\n Apple prefer 1.8, others may prefer 2.2). (Default = 1.8)\n"]
    pub fn ulConfigSetFontGamma(config: ULConfig, font_gamma: f64);
}
extern "C" {
    #[doc = "\n Global user-defined CSS string (included before any CSS on the page).\n\n You can use this to override default styles for various elements on the page.\n\n @note This is an actual string of CSS, not a file path.\n"]
    pub fn ulConfigSetUserStylesheet(config: ULConfig, css_string: ULString);
}
extern "C" {
    #[doc = "\n Whether or not to continuously repaint any Views, regardless if they are dirty.\n\n This is mainly used to diagnose painting/shader issues and profile performance.\n\n (Default = False)\n"]
    pub fn ulConfigSetForceRepaint(config: ULConfig, enabled: bool);
}
extern "C" {
    #[doc = "\n The delay (in seconds) between every tick of a CSS animation.\n\n (Default = 1.0 / 60.0)\n"]
    pub fn ulConfigSetAnimationTimerDelay(config: ULConfig, delay: f64);
}
extern "C" {
    #[doc = "\n The delay (in seconds) between every tick of a smooth scroll animation.\n\n (Default = 1.0 / 60.0)\n"]
    pub fn ulConfigSetScrollTimerDelay(config: ULConfig, delay: f64);
}
extern "C" {
    #[doc = "\n The delay (in seconds) between every call to the recycler.\n\n The library attempts to reclaim excess memory during calls to the internal recycler. You can\n change how often this is run by modifying this value.\n\n (Default = 4.0)\n"]
    pub fn ulConfigSetRecycleDelay(config: ULConfig, delay: f64);
}
extern "C" {
    #[doc = "\n The size of WebCore's memory cache in bytes.\n\n @note  You should increase this if you anticipate handling pages with large resources, Safari\n        typically uses 128+ MiB for its cache.\n\n (Default = 64 * 1024 * 1024)\n"]
    pub fn ulConfigSetMemoryCacheSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The number of pages to keep in the cache. (Default: 0, none)\n\n @note\n \\parblock\n\n Safari typically caches about 5 pages and maintains an on-disk cache to support typical\n web-browsing activities.\n\n If you increase this, you should probably increase the memory cache size as well.\n\n \\endparblock\n\n (Default = 0)\n"]
    pub fn ulConfigSetPageCacheSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The system's physical RAM size in bytes.\n\n JavaScriptCore tries to detect the system's physical RAM size to set reasonable allocation\n limits. Set this to anything other than 0 to override the detected value. Size is in bytes.\n\n This can be used to force JavaScriptCore to be more conservative with its allocation strategy\n (at the cost of some performance).\n"]
    pub fn ulConfigSetOverrideRAMSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The minimum size of large VM heaps in JavaScriptCore.\n\n Set this to a lower value to make these heaps start with a smaller initial value.\n\n (Default = 32 * 1024 * 1024)\n"]
    pub fn ulConfigSetMinLargeHeapSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The minimum size of small VM heaps in JavaScriptCore.\n\n Set this to a lower value to make these heaps start with a smaller initial value.\n\n (Default = 1 * 1024 * 1024)\n"]
    pub fn ulConfigSetMinSmallHeapSize(config: ULConfig, size: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n The number of threads to use in the Renderer (for parallel painting on the CPU, etc.).\n\n You can set this to a certain number to limit the number of threads to spawn.\n\n @note\n \\parblock\n\n If this value is 0, the number of threads will be determined at runtime using the following\n formula:\n\n   ```\n   max(PhysicalProcessorCount() - 1, 1)\n   ```\n\n \\endparblock\n"]
    pub fn ulConfigSetNumRendererThreads(
        config: ULConfig,
        num_renderer_threads: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n The max amount of time (in seconds) to allow repeating timers to run during each call to\n Renderer::Update.\n\n The library will attempt to throttle timers if this time budget is exceeded.\n\n (Default = 1.0 / 200.0)\n"]
    pub fn ulConfigSetMaxUpdateTime(config: ULConfig, max_update_time: f64);
}
extern "C" {
    #[doc = "\n The alignment (in bytes) of the BitmapSurface when using the CPU renderer.\n\n The underlying bitmap associated with each BitmapSurface will have row_bytes padded to reach\n this alignment.\n\n Aligning the bitmap helps improve performance when using the CPU renderer. Determining the\n proper value to use depends on the CPU architecture and max SIMD instruction set used.\n\n We generally target the 128-bit SSE2 instruction set across most PC platforms so '16' is a safe\n value to use.\n\n You can set this to '0' to perform no padding (row_bytes will always be width * 4) at a slight\n cost to performance.\n\n (Default = 16)\n"]
    pub fn ulConfigSetBitmapAlignment(config: ULConfig, bitmap_alignment: ::std::os::raw::c_uint);
}
#[doc = "\n The callback invoked when the FileSystem wants to check if a file path exists, return true if it\n exists.\n"]
pub type ULFileSystemFileExistsCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> bool>;
#[doc = "\n Get the mime-type of the file (eg \"text/html\").\n\n This is usually determined by analyzing the file extension.\n\n If a mime-type cannot be determined, you should return \"application/unknown\" for this value.\n\n The library will consume the result and call ulDestroyString() after this call returns.\n"]
pub type ULFileSystemGetFileMimeTypeCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> ULString>;
#[doc = "\n Get the charset / encoding of the file (eg \"utf-8\").\n\n This is only important for text-based files and is usually determined by analyzing the\n contents of the file.\n\n If a charset cannot be determined, it's usually safe to return \"utf-8\" for this value.\n\n The library will consume the result and call ulDestroyString() after this call returns.\n"]
pub type ULFileSystemGetFileCharsetCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> ULString>;
#[doc = "\n Open file for reading and map it to a Buffer.\n\n To minimize copies, you should map the requested file into memory and use ulCreateBuffer()\n to wrap the data pointer (unmapping should be performed in the destruction callback).\n\n If the file was unable to be opened, you should return NULL for this value.\n"]
pub type ULFileSystemOpenFileCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> ULBuffer>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULFileSystem {
    pub file_exists: ULFileSystemFileExistsCallback,
    pub get_file_mime_type: ULFileSystemGetFileMimeTypeCallback,
    pub get_file_charset: ULFileSystemGetFileCharsetCallback,
    pub open_file: ULFileSystemOpenFileCallback,
}
extern "C" {
    #[doc = "\n Create string from null-terminated ASCII C-string.\n"]
    pub fn ulCreateString(str_: *const ::std::os::raw::c_char) -> ULString;
}
extern "C" {
    #[doc = "\n Create string from UTF-8 buffer.\n"]
    pub fn ulCreateStringUTF8(str_: *const ::std::os::raw::c_char, len: usize) -> ULString;
}
extern "C" {
    #[doc = "\n Create string from UTF-16 buffer.\n"]
    pub fn ulCreateStringUTF16(str_: *mut ULChar16, len: usize) -> ULString;
}
extern "C" {
    #[doc = "\n Create string from copy of existing string.\n"]
    pub fn ulCreateStringFromCopy(str_: ULString) -> ULString;
}
extern "C" {
    #[doc = "\n Destroy string (you should destroy any strings you explicitly Create).\n"]
    pub fn ulDestroyString(str_: ULString);
}
extern "C" {
    #[doc = "\n Get native UTF-8 buffer data (always null-terminated).\n"]
    pub fn ulStringGetData(str_: ULString) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\n Get length (in bytes) of the UTF-8 buffer data, not including null terminator.\n"]
    pub fn ulStringGetLength(str_: ULString) -> usize;
}
extern "C" {
    #[doc = "\n Whether this string is empty or not.\n"]
    pub fn ulStringIsEmpty(str_: ULString) -> bool;
}
extern "C" {
    #[doc = "\n Replaces the contents of 'str' with the contents of 'new_str'\n"]
    pub fn ulStringAssignString(str_: ULString, new_str: ULString);
}
extern "C" {
    #[doc = "\n Replaces the contents of 'str' with the contents of a C-string.\n"]
    pub fn ulStringAssignCString(str_: ULString, c_str: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "\n Create a font file from an on-disk file path.\n\n @note  The file path should already exist.\n"]
    pub fn ulFontFileCreateFromFilePath(file_path: ULString) -> ULFontFile;
}
extern "C" {
    #[doc = "\n Create a font file from an in-memory buffer.\n"]
    pub fn ulFontFileCreateFromBuffer(buffer: ULBuffer) -> ULFontFile;
}
extern "C" {
    #[doc = "\n Destroy font file\n"]
    pub fn ulDestroyFontFile(font_file: ULFontFile);
}
#[doc = "\n Fallback font family name. Will be used if all other fonts fail to load.\n\n @note  This font should be guaranteed to exist (eg, ULFontLoader::load should not fail when\n        when passed this font family name).\n\n @note  The returned ULString instance will be consumed (ulDestroyString will be called on it).\n"]
pub type ULFontLoaderGetFallbackFont = ::std::option::Option<unsafe extern "C" fn() -> ULString>;
#[doc = "\n Fallback font family name that can render the specified characters. This is mainly used to\n support CJK (Chinese, Japanese, Korean) text display.\n\n @param  characters  One or more UTF-16 characters. This is almost always a single character.\n\n @param  weight      Font weight.\n\n @param  italic      Whether or not italic is requested.\n\n @return  Should return a font family name that can render the text. The returned ULString\n          instance will be consumed (ulDestroyString will be called on it).\n"]
pub type ULFontLoaderGetFallbackFontForCharacters = ::std::option::Option<
    unsafe extern "C" fn(
        characters: ULString,
        weight: ::std::os::raw::c_int,
        italic: bool,
    ) -> ULString,
>;
#[doc = "\n Get the actual font file data (TTF/OTF) for a given font description.\n\n @param  family  Font family name.\n\n @param  weight  Font weight.\n\n @param  italic  Whether or not italic is requested.\n\n @return  A font file matching the given description (either an on-disk font filepath or an\n          in-memory file buffer). You can return NULL here and the loader will fallback to\n          another font.\n"]
pub type ULFontLoaderLoad = ::std::option::Option<
    unsafe extern "C" fn(
        family: ULString,
        weight: ::std::os::raw::c_int,
        italic: bool,
    ) -> ULFontFile,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULFontLoader {
    pub get_fallback_font: ULFontLoaderGetFallbackFont,
    pub get_fallback_font_for_characters: ULFontLoaderGetFallbackFontForCharacters,
    pub load: ULFontLoaderLoad,
}
extern "C" {
    #[doc = "\n Whether or not a ULRect is empty (all members equal to 0)\n"]
    pub fn ulRectIsEmpty(rect: ULRect) -> bool;
}
extern "C" {
    #[doc = "\n Create an empty ULRect (all members equal to 0)\n"]
    pub fn ulRectMakeEmpty() -> ULRect;
}
extern "C" {
    #[doc = "\n Whether or not a ULIntRect is empty (all members equal to 0)\n"]
    pub fn ulIntRectIsEmpty(rect: ULIntRect) -> bool;
}
extern "C" {
    #[doc = "\n Create an empty ULIntRect (all members equal to 0)\n"]
    pub fn ulIntRectMakeEmpty() -> ULIntRect;
}
#[doc = "\n Render buffer description.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULRenderBuffer {
    pub texture_id: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub has_stencil_buffer: bool,
    pub has_depth_buffer: bool,
}
#[doc = "\n Vertex layout for path vertices.\n\n (this struct's members aligned on single-byte boundaries)\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULVertex_2f_4ub_2f {
    pub pos: [f32; 2usize],
    pub color: [::std::os::raw::c_uchar; 4usize],
    pub obj: [f32; 2usize],
}
#[doc = "\n Vertex layout for quad vertices.\n\n (this struct's members aligned on single-byte boundaries)\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULVertex_2f_4ub_2f_2f_28f {
    pub pos: [f32; 2usize],
    pub color: [::std::os::raw::c_uchar; 4usize],
    pub tex: [f32; 2usize],
    pub obj: [f32; 2usize],
    pub data0: [f32; 4usize],
    pub data1: [f32; 4usize],
    pub data2: [f32; 4usize],
    pub data3: [f32; 4usize],
    pub data4: [f32; 4usize],
    pub data5: [f32; 4usize],
    pub data6: [f32; 4usize],
}
pub const ULVertexBufferFormat_kVertexBufferFormat_2f_4ub_2f: ULVertexBufferFormat = 0;
pub const ULVertexBufferFormat_kVertexBufferFormat_2f_4ub_2f_2f_28f: ULVertexBufferFormat = 1;
#[doc = "\n Vertex formats.\n"]
pub type ULVertexBufferFormat = ::std::os::raw::c_int;
#[doc = "\n Vertex buffer data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULVertexBuffer {
    pub format: ULVertexBufferFormat,
    pub size: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_uchar,
}
impl Default for ULVertexBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n Vertex index type.\n"]
pub type ULIndexType = ::std::os::raw::c_uint;
#[doc = "\n Vertex index buffer data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULIndexBuffer {
    pub size: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_uchar,
}
impl Default for ULIndexBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ULShaderType_kShaderType_Fill: ULShaderType = 0;
pub const ULShaderType_kShaderType_FillPath: ULShaderType = 1;
#[doc = "\n Shader types, used with ULGPUState::shader_type\n\n Each of these correspond to a vertex/pixel shader pair. You can find stock shader code for these\n in the `shaders` folder of the AppCore repo.\n"]
pub type ULShaderType = ::std::os::raw::c_int;
#[doc = "\n Raw 4x4 matrix as an array of floats\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULMatrix4x4 {
    pub data: [f32; 16usize],
}
#[doc = "\n 4-component float vector\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULvec4 {
    pub value: [f32; 4usize],
}
#[doc = "\n GPU State description.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULGPUState {
    #[doc = " Viewport width in pixels"]
    pub viewport_width: ::std::os::raw::c_uint,
    #[doc = " Viewport height in pixels"]
    pub viewport_height: ::std::os::raw::c_uint,
    #[doc = " Transform matrix-- you should multiply this with the screen-space orthographic projection\n matrix then pass to the vertex shader."]
    pub transform: ULMatrix4x4,
    #[doc = " Whether or not we should enable texturing for the current draw command."]
    pub enable_texturing: bool,
    #[doc = " Whether or not we should enable blending for the current draw command. If blending is\n disabled, any drawn pixels should overwrite existing. Mainly used so we can modify alpha\n values of the RenderBuffer during scissored clears."]
    pub enable_blend: bool,
    #[doc = " The vertex/pixel shader program pair to use for the current draw command. You should cast this\n to ShaderType to get the corresponding enum."]
    pub shader_type: ::std::os::raw::c_uchar,
    #[doc = " The render buffer to use for the current draw command."]
    pub render_buffer_id: ::std::os::raw::c_uint,
    #[doc = " The texture id to bind to slot #1. (Will be 0 if none)"]
    pub texture_1_id: ::std::os::raw::c_uint,
    #[doc = " The texture id to bind to slot #2. (Will be 0 if none)"]
    pub texture_2_id: ::std::os::raw::c_uint,
    #[doc = " The texture id to bind to slot #3. (Will be 0 if none)"]
    pub texture_3_id: ::std::os::raw::c_uint,
    #[doc = " The following four members are passed to the pixel shader via uniforms."]
    pub uniform_scalar: [f32; 8usize],
    pub uniform_vector: [ULvec4; 8usize],
    pub clip_size: ::std::os::raw::c_uchar,
    pub clip: [ULMatrix4x4; 8usize],
    #[doc = " Whether or not scissor testing should be used for the current draw\n command."]
    pub enable_scissor: bool,
    #[doc = " The scissor rect to use for scissor testing (units in pixels)"]
    pub scissor_rect: ULIntRect,
}
pub const ULCommandType_kCommandType_ClearRenderBuffer: ULCommandType = 0;
pub const ULCommandType_kCommandType_DrawGeometry: ULCommandType = 1;
#[doc = "\n Command types, used with ULCommand::command_type\n"]
pub type ULCommandType = ::std::os::raw::c_int;
#[doc = "\n Command description.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULCommand {
    pub command_type: ::std::os::raw::c_uchar,
    pub gpu_state: ULGPUState,
    #[doc = " The following members are only used with kCommandType_DrawGeometry"]
    pub geometry_id: ::std::os::raw::c_uint,
    pub indices_count: ::std::os::raw::c_uint,
    pub indices_offset: ::std::os::raw::c_uint,
}
#[doc = "\n Command list, @see ULGPUDriverUpdateCommandList"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ULCommandList {
    pub size: ::std::os::raw::c_uint,
    pub commands: *mut ULCommand,
}
impl Default for ULCommandList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n The callback invoked when the GPUDriver will begin dispatching commands (such as CreateTexture\n and UpdateCommandList) during the current call to ulRender().\n"]
pub type ULGPUDriverBeginSynchronizeCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "\n The callback invoked when the GPUDriver has finished dispatching commands during the current\n call to ulRender().\n"]
pub type ULGPUDriverEndSynchronizeCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "\n The callback invoked when the GPUDriver wants to get the next available texture ID.\n"]
pub type ULGPUDriverNextTextureIdCallback =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = "\n The callback invoked when the GPUDriver wants to create a texture with a\n certain ID and optional bitmap.\n\n @note: If the Bitmap is empty (ulBitmapIsEmpty), then a RTT Texture should be created\n        instead. This will be used as a backing texture for a new RenderBuffer.\n"]
pub type ULGPUDriverCreateTextureCallback = ::std::option::Option<
    unsafe extern "C" fn(texture_id: ::std::os::raw::c_uint, bitmap: ULBitmap),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to update an existing non-RTT texture with new\n bitmap data.\n"]
pub type ULGPUDriverUpdateTextureCallback = ::std::option::Option<
    unsafe extern "C" fn(texture_id: ::std::os::raw::c_uint, bitmap: ULBitmap),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to destroy a texture.\n"]
pub type ULGPUDriverDestroyTextureCallback =
    ::std::option::Option<unsafe extern "C" fn(texture_id: ::std::os::raw::c_uint)>;
#[doc = "\n The callback invoked when the GPUDriver wants to generate the next available render buffer ID.\n"]
pub type ULGPUDriverNextRenderBufferIdCallback =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = "\n The callback invoked when the GPUDriver wants to create a render buffer with certain ID and\n buffer description.\n"]
pub type ULGPUDriverCreateRenderBufferCallback = ::std::option::Option<
    unsafe extern "C" fn(render_buffer_id: ::std::os::raw::c_uint, buffer: ULRenderBuffer),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to destroy a render buffer\n"]
pub type ULGPUDriverDestroyRenderBufferCallback =
    ::std::option::Option<unsafe extern "C" fn(render_buffer_id: ::std::os::raw::c_uint)>;
#[doc = "\n The callback invoked when the GPUDriver wants to generate the next available geometry ID.\n"]
pub type ULGPUDriverNextGeometryIdCallback =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = "\n The callback invoked when the GPUDriver wants to create geometry with certain ID and\n vertex/index data.\n"]
pub type ULGPUDriverCreateGeometryCallback = ::std::option::Option<
    unsafe extern "C" fn(
        geometry_id: ::std::os::raw::c_uint,
        vertices: ULVertexBuffer,
        indices: ULIndexBuffer,
    ),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to update existing geometry with new vertex/index\n data.\n"]
pub type ULGPUDriverUpdateGeometryCallback = ::std::option::Option<
    unsafe extern "C" fn(
        geometry_id: ::std::os::raw::c_uint,
        vertices: ULVertexBuffer,
        indices: ULIndexBuffer,
    ),
>;
#[doc = "\n The callback invoked when the GPUDriver wants to destroy geometry.\n"]
pub type ULGPUDriverDestroyGeometryCallback =
    ::std::option::Option<unsafe extern "C" fn(geometry_id: ::std::os::raw::c_uint)>;
#[doc = "\n The callback invoked when the GPUDriver wants to update the command list (you should copy the\n commands to your own structure).\n"]
pub type ULGPUDriverUpdateCommandListCallback =
    ::std::option::Option<unsafe extern "C" fn(list: ULCommandList)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULGPUDriver {
    pub begin_synchronize: ULGPUDriverBeginSynchronizeCallback,
    pub end_synchronize: ULGPUDriverEndSynchronizeCallback,
    pub next_texture_id: ULGPUDriverNextTextureIdCallback,
    pub create_texture: ULGPUDriverCreateTextureCallback,
    pub update_texture: ULGPUDriverUpdateTextureCallback,
    pub destroy_texture: ULGPUDriverDestroyTextureCallback,
    pub next_render_buffer_id: ULGPUDriverNextRenderBufferIdCallback,
    pub create_render_buffer: ULGPUDriverCreateRenderBufferCallback,
    pub destroy_render_buffer: ULGPUDriverDestroyRenderBufferCallback,
    pub next_geometry_id: ULGPUDriverNextGeometryIdCallback,
    pub create_geometry: ULGPUDriverCreateGeometryCallback,
    pub update_geometry: ULGPUDriverUpdateGeometryCallback,
    pub destroy_geometry: ULGPUDriverDestroyGeometryCallback,
    pub update_command_list: ULGPUDriverUpdateCommandListCallback,
}
extern "C" {
    #[doc = "\n Sets up an orthographic projection matrix with a certain viewport width and height, multiplies\n it by 'transform', and returns the result.\n\n This should be used to calculate the model-view projection matrix for the vertex shaders using\n the current ULGPUState.\n\n The 'flip_y' can be optionally used to flip the Y coordinate-space. (Usually flip_y == true for\n OpenGL)\n"]
    pub fn ulApplyProjection(
        transform: ULMatrix4x4,
        viewport_width: f32,
        viewport_height: f32,
        flip_y: bool,
    ) -> ULMatrix4x4;
}
extern "C" {
    #[doc = "\n Create a key event, @see KeyEvent for help with the following parameters.\n"]
    pub fn ulCreateKeyEvent(
        type_: ULKeyEventType,
        modifiers: ::std::os::raw::c_uint,
        virtual_key_code: ::std::os::raw::c_int,
        native_key_code: ::std::os::raw::c_int,
        text: ULString,
        unmodified_text: ULString,
        is_keypad: bool,
        is_auto_repeat: bool,
        is_system_key: bool,
    ) -> ULKeyEvent;
}
extern "C" {
    #[doc = "\n Create a key event from native Windows event.\n"]
    pub fn ulCreateKeyEventWindows(
        type_: ULKeyEventType,
        wparam: ::std::os::raw::c_ulonglong,
        lparam: ::std::os::raw::c_longlong,
        is_system_key: bool,
    ) -> ULKeyEvent;
}
extern "C" {
    #[doc = "\n Destroy a key event.\n"]
    pub fn ulDestroyKeyEvent(evt: ULKeyEvent);
}
#[repr(i32)]
#[doc = " Logger"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ULLogLevel {
    kLogLevel_Error = 0,
    kLogLevel_Warning = 1,
    kLogLevel_Info = 2,
}
#[doc = "\n The callback invoked when the library wants to print a message to the log.\n"]
pub type ULLoggerLogMessageCallback =
    ::std::option::Option<unsafe extern "C" fn(log_level: ULLogLevel, message: ULString)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULLogger {
    pub log_message: ULLoggerLogMessageCallback,
}
extern "C" {
    #[doc = "\n Create a mouse event, @see MouseEvent for help using this function.\n"]
    pub fn ulCreateMouseEvent(
        type_: ULMouseEventType,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        button: ULMouseButton,
    ) -> ULMouseEvent;
}
extern "C" {
    #[doc = "\n Destroy a mouse event.\n"]
    pub fn ulDestroyMouseEvent(evt: ULMouseEvent);
}
extern "C" {
    #[doc = "\n Width (in pixels).\n"]
    pub fn ulSurfaceGetWidth(surface: ULSurface) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Height (in pixels).\n"]
    pub fn ulSurfaceGetHeight(surface: ULSurface) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Number of bytes between rows (usually width * 4)\n"]
    pub fn ulSurfaceGetRowBytes(surface: ULSurface) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Size in bytes.\n"]
    pub fn ulSurfaceGetSize(surface: ULSurface) -> usize;
}
extern "C" {
    #[doc = "\n Lock the pixel buffer and get a pointer to the beginning of the data for reading/writing.\n\n Native pixel format is premultiplied BGRA 32-bit (8 bits per channel).\n"]
    pub fn ulSurfaceLockPixels(surface: ULSurface) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Unlock the pixel buffer.\n"]
    pub fn ulSurfaceUnlockPixels(surface: ULSurface);
}
extern "C" {
    #[doc = "\n Resize the pixel buffer to a certain width and height (both in pixels).\n\n This should never be called while pixels are locked.\n"]
    pub fn ulSurfaceResize(
        surface: ULSurface,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n Set the dirty bounds to a certain value.\n\n This is called after the Renderer paints to an area of the pixel buffer. (The new value will be\n joined with the existing dirty_bounds())\n"]
    pub fn ulSurfaceSetDirtyBounds(surface: ULSurface, bounds: ULIntRect);
}
extern "C" {
    #[doc = "\n Get the dirty bounds.\n\n This value can be used to determine which portion of the pixel buffer has been updated since the\n last call to ulSurfaceClearDirtyBounds().\n\n The general algorithm to determine if a Surface needs display is:\n <pre>\n   if (!ulIntRectIsEmpty(ulSurfaceGetDirtyBounds(surface))) {\n       // Surface pixels are dirty and needs display.\n       // Cast Surface to native Surface and use it here (pseudo code)\n       DisplaySurface(surface);\n\n       // Once you're done, clear the dirty bounds:\n       ulSurfaceClearDirtyBounds(surface);\n  }\n  </pre>\n"]
    pub fn ulSurfaceGetDirtyBounds(surface: ULSurface) -> ULIntRect;
}
extern "C" {
    #[doc = "\n Clear the dirty bounds.\n\n You should call this after you're done displaying the Surface.\n"]
    pub fn ulSurfaceClearDirtyBounds(surface: ULSurface);
}
extern "C" {
    #[doc = "\n Get the underlying user data pointer (this is only valid if you have set a custom surface\n implementation via ulPlatformSetSurfaceDefinition).\n\n This will return nullptr if this surface is the default ULBitmapSurface.\n"]
    pub fn ulSurfaceGetUserData(surface: ULSurface) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Get the underlying Bitmap from the default Surface.\n\n @note  Do not call ulDestroyBitmap() on the returned value, it is owned by the surface.\n"]
    pub fn ulBitmapSurfaceGetBitmap(surface: ULBitmapSurface) -> ULBitmap;
}
#[doc = "\n The callback invoked when a Surface is created.\n\n @param  width  The width in pixels.\n @param  height  The height in pixels.\n\n @return  This callback should return a pointer to user-defined data for the instance. This user\n          data pointer will be passed to all other callbacks when operating on the instance.\n"]
pub type ULSurfaceDefinitionCreateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = "\n The callback invoked when a Surface is destroyed.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionDestroyCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = "\n The callback invoked when a Surface's width (in pixels) is requested.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetWidthCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
#[doc = "\n The callback invoked when a Surface's height (in pixels) is requested.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetHeightCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
#[doc = "\n The callback invoked when a Surface's row bytes is requested.\n\n @note  This value is also known as \"stride\". Usually width * 4.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetRowBytesCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
#[doc = "\n The callback invoked when a Surface's size (in bytes) is requested.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetSizeCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> usize>;
#[doc = "\n The callback invoked when a Surface's pixel buffer is requested to be locked for reading/writing\n (should return a pointer to locked bytes).\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionLockPixelsCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[doc = "\n The callback invoked when a Surface's pixel buffer is requested to be unlocked after previously\n being locked.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionUnlockPixelsCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = "\n The callback invoked when a Surface is requested to be resized to a certain width/height.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n\n @param  width      Width in pixels.\n\n @param  height     Height in pixels.\n"]
pub type ULSurfaceDefinitionResizeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ULSurfaceDefinition {
    pub create: ULSurfaceDefinitionCreateCallback,
    pub destroy: ULSurfaceDefinitionDestroyCallback,
    pub get_width: ULSurfaceDefinitionGetWidthCallback,
    pub get_height: ULSurfaceDefinitionGetHeightCallback,
    pub get_row_bytes: ULSurfaceDefinitionGetRowBytesCallback,
    pub get_size: ULSurfaceDefinitionGetSizeCallback,
    pub lock_pixels: ULSurfaceDefinitionLockPixelsCallback,
    pub unlock_pixels: ULSurfaceDefinitionUnlockPixelsCallback,
    pub resize: ULSurfaceDefinitionResizeCallback,
}
extern "C" {
    #[doc = "\n Set a custom Logger implementation.\n\n This is used to log debug messages to the console or to a log file.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n\n @note  ulCreateApp() will use the default logger if you never call this.\n\n @note  If you're not using ulCreateApp(), (eg, using ulCreateRenderer()) you can still use the\n        default logger by calling ulEnableDefaultLogger() (@see <AppCore/CAPI.h>)\n"]
    pub fn ulPlatformSetLogger(logger: ULLogger);
}
extern "C" {
    #[doc = "\n Set a custom FileSystem implementation.\n\n The library uses this to load all file URLs (eg, <file:///page.html>).\n\n You can provide the library with your own FileSystem implementation so that file assets are\n loaded from your own pipeline.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n\n @warning This is required to be defined before calling ulCreateRenderer()\n\n @note  ulCreateApp() will use the default platform file system if you never call this.\n\n @note  If you're not using ulCreateApp(), (eg, using ulCreateRenderer()) you can still use the\n        default platform file system by calling ulEnablePlatformFileSystem()'\n        (@see <AppCore/CAPI.h>)\n"]
    pub fn ulPlatformSetFileSystem(file_system: ULFileSystem);
}
extern "C" {
    #[doc = "\n Set a custom FontLoader implementation.\n\n The library uses this to load all system fonts.\n\n Every operating system has its own library of installed system fonts. The FontLoader interface\n is used to lookup these fonts and fetch the actual font data (raw TTF/OTF file data) for a given\n given font description.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n\n @warning This is required to be defined before calling ulCreateRenderer()\n\n @note  ulCreateApp() will use the default platform font loader if you never call this.\n\n @note  If you're not using ulCreateApp(), (eg, using ulCreateRenderer()) you can still use the\n        default platform font loader by calling ulEnablePlatformFontLoader()'\n        (@see <AppCore/CAPI.h>)\n"]
    pub fn ulPlatformSetFontLoader(font_loader: ULFontLoader);
}
extern "C" {
    #[doc = "\n Set a custom Surface implementation.\n\n This can be used to wrap a platform-specific GPU texture, Windows DIB, macOS CGImage, or any\n other pixel buffer target for display on screen.\n\n By default, the library uses a bitmap surface for all surfaces but you can override this by\n providing your own surface definition here.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n"]
    pub fn ulPlatformSetSurfaceDefinition(surface_definition: ULSurfaceDefinition);
}
extern "C" {
    #[doc = "\n Set a custom GPUDriver implementation.\n\n This should be used if you have enabled the GPU renderer in the Config and are using\n ulCreateRenderer() (which does not provide its own GPUDriver implementation).\n\n The GPUDriver interface is used by the library to dispatch GPU calls to your native GPU context\n (eg, D3D11, Metal, OpenGL, Vulkan, etc.) There are reference implementations for this interface\n in the AppCore repo.\n\n You should call this before ulCreateRenderer().\n"]
    pub fn ulPlatformSetGPUDriver(gpu_driver: ULGPUDriver);
}
extern "C" {
    #[doc = "\n Set a custom Clipboard implementation.\n\n This should be used if you are using ulCreateRenderer() (which does not provide its own\n clipboard implementation).\n\n The Clipboard interface is used by the library to make calls to the system's native clipboard\n (eg, cut, copy, paste).\n\n You should call this before ulCreateRenderer().\n"]
    pub fn ulPlatformSetClipboard(clipboard: ULClipboard);
}
extern "C" {
    #[doc = "\n Create the core renderer singleton for the library directly.\n\n Unlike ulCreateApp(), this does not use any native windows for drawing and allows you to manage\n your own runloop and painting. This method is recommended for those wishing to integrate the\n library into a game.\n\n This singleton manages the lifetime of all Views and coordinates all painting, rendering,\n network requests, and event dispatch.\n\n You should only call this once per process lifetime.\n\n You must set up your platform handlers before calling this. At a minimum, you must call\n ulPlatformSetFileSystem() and  ulPlatformSetFontLoader() before calling this.\n\n @note  You should not call this if you are using ulCreateApp(), it creates its own renderer and\n        provides default implementations for various platform handlers automatically.\n"]
    pub fn ulCreateRenderer(config: ULConfig) -> ULRenderer;
}
extern "C" {
    #[doc = "\n Destroy the renderer.\n"]
    pub fn ulDestroyRenderer(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Update timers and dispatch internal callbacks (JavaScript and network).\n"]
    pub fn ulUpdate(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Notify the renderer that a display has refreshed (you should call this after vsync).\n\n This updates animations, smooth scroll, and window.requestAnimationFrame() for all Views\n matching the display id.\n"]
    pub fn ulRefreshDisplay(renderer: ULRenderer, display_id: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n Render all active Views.\n"]
    pub fn ulRender(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Attempt to release as much memory as possible. Don't call this from any callbacks or driver\n code.\n"]
    pub fn ulPurgeMemory(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Print detailed memory usage statistics to the log. (@see ulPlatformSetLogger)\n"]
    pub fn ulLogMemoryUsage(renderer: ULRenderer);
}
extern "C" {
    #[doc = "\n Start the remote inspector server.\n\n While the remote inspector is active, Views that are loaded into this renderer\n will be able to be remotely inspected from another Ultralight instance either locally\n (another app on same machine) or remotely (over the network) by navigating a View to:\n\n \\code\n   inspector://<ADDRESS>:<PORT>\n \\endcode\n\n @return  Returns whether the server started successfully or not.\n"]
    pub fn ulStartRemoteInspectorServer(
        renderer: ULRenderer,
        address: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
    ) -> bool;
}
extern "C" {
    #[doc = "\n Describe the details of a gamepad, to be used with ulFireGamepadEvent and related\n events below. This can be called multiple times with the same index if the details change.\n\n @param  renderer  The active renderer instance.\n\n @param  index   The unique index (or \"connection slot\") of the gamepad. For example,\n                 controller #1 would be \"1\", controller #2 would be \"2\" and so on.\n\n @param  id      A string ID representing the device, this will be made available\n                 in JavaScript as gamepad.id\n\n @param  axis_count  The number of axes on the device.\n\n @param  button_count  The number of buttons on the device.\n"]
    pub fn ulSetGamepadDetails(
        renderer: ULRenderer,
        index: ::std::os::raw::c_uint,
        id: ULString,
        axis_count: ::std::os::raw::c_uint,
        button_count: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n Fire a gamepad event (connection / disconnection).\n\n @note  The gamepad should first be described via ulSetGamepadDetails before calling this\n        function.\n\n @see <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad>\n"]
    pub fn ulFireGamepadEvent(renderer: ULRenderer, evt: ULGamepadEvent);
}
extern "C" {
    #[doc = "\n Fire a gamepad axis event (to be called when an axis value is changed).\n\n @note  The gamepad should be connected via a previous call to ulFireGamepadEvent.\n\n @see <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/axes>\n"]
    pub fn ulFireGamepadAxisEvent(renderer: ULRenderer, evt: ULGamepadAxisEvent);
}
extern "C" {
    #[doc = "\n Fire a gamepad button event (to be called when a button value is changed).\n\n @note  The gamepad should be connected via a previous call to ulFireGamepadEvent.\n\n @see <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/buttons>\n"]
    pub fn ulFireGamepadButtonEvent(renderer: ULRenderer, evt: ULGamepadButtonEvent);
}
extern "C" {
    #[doc = "\n Create a scroll event, @see ScrollEvent for help using this function.\n"]
    pub fn ulCreateScrollEvent(
        type_: ULScrollEventType,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) -> ULScrollEvent;
}
extern "C" {
    #[doc = "\n Destroy a scroll event.\n"]
    pub fn ulDestroyScrollEvent(evt: ULScrollEvent);
}
extern "C" {
    #[doc = "\n Create a gamepad event, see GamepadEvent for help using this function.\n"]
    pub fn ulCreateGamepadEvent(
        index: ::std::os::raw::c_uint,
        type_: ULGamepadEventType,
    ) -> ULGamepadEvent;
}
extern "C" {
    #[doc = "\n Destroy a gamepad event.\n"]
    pub fn ulDestroyGamepadEvent(evt: ULGamepadEvent);
}
extern "C" {
    #[doc = "\n Create a gamepad axis event, see GamepadAxisEvent for help using this function.\n"]
    pub fn ulCreateGamepadAxisEvent(
        index: ::std::os::raw::c_uint,
        axis_index: ::std::os::raw::c_uint,
        value: f64,
    ) -> ULGamepadAxisEvent;
}
extern "C" {
    #[doc = "\n Destroy a gamepad axis event.\n"]
    pub fn ulDestroyGamepadAxisEvent(evt: ULGamepadAxisEvent);
}
extern "C" {
    #[doc = "\n Create a gamepad button event, see GamepadButtonEvent for help using this function.\n"]
    pub fn ulCreateGamepadButtonEvent(
        index: ::std::os::raw::c_uint,
        button_index: ::std::os::raw::c_uint,
        value: f64,
    ) -> ULGamepadButtonEvent;
}
extern "C" {
    #[doc = "\n Destroy a gamepad button event.\n"]
    pub fn ulDestroyGamepadButtonEvent(evt: ULGamepadButtonEvent);
}
extern "C" {
    #[doc = "\n Create a Session to store local data in (such as cookies, local storage, application cache,\n indexed db, etc).\n"]
    pub fn ulCreateSession(renderer: ULRenderer, is_persistent: bool, name: ULString) -> ULSession;
}
extern "C" {
    #[doc = "\n Destroy a Session.\n"]
    pub fn ulDestroySession(session: ULSession);
}
extern "C" {
    #[doc = "\n Get the default session (persistent session named \"default\").\n\n @note  This session is owned by the Renderer, you shouldn't destroy it.\n"]
    pub fn ulDefaultSession(renderer: ULRenderer) -> ULSession;
}
extern "C" {
    #[doc = "\n Whether or not is persistent (backed to disk).\n"]
    pub fn ulSessionIsPersistent(session: ULSession) -> bool;
}
extern "C" {
    #[doc = "\n Unique name identifying the session (used for unique disk path).\n"]
    pub fn ulSessionGetName(session: ULSession) -> ULString;
}
extern "C" {
    #[doc = "\n Unique numeric Id for the session.\n"]
    pub fn ulSessionGetId(session: ULSession) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = "\n The disk path to write to (used by persistent sessions only).\n"]
    pub fn ulSessionGetDiskPath(session: ULSession) -> ULString;
}
extern "C" {
    #[doc = "\n Create view configuration with default values (see <Ultralight/platform/View.h>).\n"]
    pub fn ulCreateViewConfig() -> ULViewConfig;
}
extern "C" {
    #[doc = "\n Destroy view configuration.\n"]
    pub fn ulDestroyViewConfig(config: ULViewConfig);
}
extern "C" {
    #[doc = "\n Set a user-generated id of the display (monitor, TV, or screen) that the View will be shown on.\n\n Animations are driven based on the physical refresh rate of the display. Multiple Views can\n share the same display.\n\n\n @note This is automatically managed for you when ulCreateApp() is used.\n\n @see ulRefreshDisplay()\n"]
    pub fn ulViewConfigSetDisplayId(config: ULViewConfig, display_id: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n Set whether to render using the GPU renderer (accelerated) or the CPU renderer (unaccelerated).\n\n This option is only valid if you're managing the Renderer yourself (eg, you've previously\n called ulCreateRenderer() instead of ulCreateApp()).\n\n When true, the View will be rendered to an offscreen GPU texture using the GPU driver set in\n ulPlatformSetGPUDriver(). You can fetch details for the texture via ulViewGetRenderTarget().\n\n When false (the default), the View will be rendered to an offscreen pixel buffer using the\n multithreaded CPU renderer. This pixel buffer can optionally be provided by the user--\n for more info see ulViewGetSurface().\n"]
    pub fn ulViewConfigSetIsAccelerated(config: ULViewConfig, is_accelerated: bool);
}
extern "C" {
    #[doc = "\n Set whether images should be enabled (Default = True).\n"]
    pub fn ulViewConfigSetIsTransparent(config: ULViewConfig, is_transparent: bool);
}
extern "C" {
    #[doc = "\n Set the initial device scale, ie. the amount to scale page units to screen pixels. This should be\n set to the scaling factor of the device that the View is displayed on. (Default = 1.0)\n\n @note 1.0 is equal to 100% zoom (no scaling), 2.0 is equal to 200% zoom (2x scaling)\n"]
    pub fn ulViewConfigSetInitialDeviceScale(config: ULViewConfig, initial_device_scale: f64);
}
extern "C" {
    #[doc = "\n Set whether or not the View should initially have input focus. (Default = True)\n"]
    pub fn ulViewConfigSetInitialFocus(config: ULViewConfig, is_focused: bool);
}
extern "C" {
    #[doc = "\n Set whether images should be enabled (Default = True).\n"]
    pub fn ulViewConfigSetEnableImages(config: ULViewConfig, enabled: bool);
}
extern "C" {
    #[doc = "\n Set whether JavaScript should be enabled (Default = True).\n"]
    pub fn ulViewConfigSetEnableJavaScript(config: ULViewConfig, enabled: bool);
}
extern "C" {
    #[doc = "\n Set default font-family to use (Default = Times New Roman).\n"]
    pub fn ulViewConfigSetFontFamilyStandard(config: ULViewConfig, font_name: ULString);
}
extern "C" {
    #[doc = "\n Set default font-family to use for fixed fonts, eg <pre> and <code>\n (Default = Courier New).\n"]
    pub fn ulViewConfigSetFontFamilyFixed(config: ULViewConfig, font_name: ULString);
}
extern "C" {
    #[doc = "\n Set default font-family to use for serif fonts (Default = Times New Roman).\n"]
    pub fn ulViewConfigSetFontFamilySerif(config: ULViewConfig, font_name: ULString);
}
extern "C" {
    #[doc = "\n Set default font-family to use for sans-serif fonts (Default = Arial).\n"]
    pub fn ulViewConfigSetFontFamilySansSerif(config: ULViewConfig, font_name: ULString);
}
extern "C" {
    #[doc = "\n Set user agent string (See <Ultralight/platform/Config.h> for the default).\n"]
    pub fn ulViewConfigSetUserAgent(config: ULViewConfig, agent_string: ULString);
}
extern "C" {
    #[doc = "\n Create a View with certain size (in pixels).\n\n @note  You can pass null to 'session' to use the default session.\n"]
    pub fn ulCreateView(
        renderer: ULRenderer,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        view_config: ULViewConfig,
        session: ULSession,
    ) -> ULView;
}
extern "C" {
    #[doc = "\n Destroy a View.\n"]
    pub fn ulDestroyView(view: ULView);
}
extern "C" {
    #[doc = "\n Get current URL.\n\n @note Don't destroy the returned string, it is owned by the View.\n"]
    pub fn ulViewGetURL(view: ULView) -> ULString;
}
extern "C" {
    #[doc = "\n Get current title.\n\n @note Don't destroy the returned string, it is owned by the View.\n"]
    pub fn ulViewGetTitle(view: ULView) -> ULString;
}
extern "C" {
    #[doc = "\n Get the width, in pixels.\n"]
    pub fn ulViewGetWidth(view: ULView) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height, in pixels.\n"]
    pub fn ulViewGetHeight(view: ULView) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ulViewGetDisplayId(view: ULView) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Set the display id of the View.\n\n This should be called when the View is moved to another display.\n"]
    pub fn ulViewSetDisplayId(view: ULView, display_id: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = "\n Get the device scale, ie. the amount to scale page units to screen pixels.\n\n For example, a value of 1.0 is equivalent to 100% zoom. A value of 2.0 is 200% zoom.\n"]
    pub fn ulViewGetDeviceScale(view: ULView) -> f64;
}
extern "C" {
    #[doc = "\n Set the device scale.\n"]
    pub fn ulViewSetDeviceScale(view: ULView, scale: f64);
}
extern "C" {
    #[doc = "\n Whether or not the View is GPU-accelerated. If this is false, the page will be rendered\n via the CPU renderer.\n"]
    pub fn ulViewIsAccelerated(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Whether or not the View supports transparent backgrounds.\n"]
    pub fn ulViewIsTransparent(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Check if the main frame of the page is currrently loading.\n"]
    pub fn ulViewIsLoading(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Get the RenderTarget for the View.\n\n @note  Only valid if this View is GPU accelerated.\n\n        You can use this with your GPUDriver implementation to bind and display the\n        corresponding texture in your application.\n"]
    pub fn ulViewGetRenderTarget(view: ULView) -> ULRenderTarget;
}
extern "C" {
    #[doc = "\n Get the Surface for the View (native pixel buffer that the CPU renderer draws into).\n\n @note  This operation is only valid if you're managing the Renderer yourself (eg, you've\n        previously called ulCreateRenderer() instead of ulCreateApp()).\n\n        This function will return NULL if this View is GPU accelerated.\n\n        The default Surface is BitmapSurface but you can provide your own Surface implementation\n        via ulPlatformSetSurfaceDefinition.\n\n        When using the default Surface, you can retrieve the underlying bitmap by casting\n        ULSurface to ULBitmapSurface and calling ulBitmapSurfaceGetBitmap().\n"]
    pub fn ulViewGetSurface(view: ULView) -> ULSurface;
}
extern "C" {
    #[doc = "\n Load a raw string of HTML.\n"]
    pub fn ulViewLoadHTML(view: ULView, html_string: ULString);
}
extern "C" {
    #[doc = "\n Load a URL into main frame.\n"]
    pub fn ulViewLoadURL(view: ULView, url_string: ULString);
}
extern "C" {
    #[doc = "\n Resize view to a certain width and height (in pixels).\n"]
    pub fn ulViewResize(
        view: ULView,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n Acquire the page's JSContext for use with JavaScriptCore API.\n\n @note  This call locks the context for the current thread. You should call\n        ulViewUnlockJSContext() after using the context so other worker threads can modify\n        JavaScript state.\n\n @note  The lock is recusive, it's okay to call this multiple times as long as you call\n        ulViewUnlockJSContext() the same number of times.\n"]
    pub fn ulViewLockJSContext(view: ULView) -> JSContextRef;
}
extern "C" {
    #[doc = "\n Unlock the page's JSContext after a previous call to ulViewLockJSContext().\n"]
    pub fn ulViewUnlockJSContext(view: ULView);
}
extern "C" {
    #[doc = "\n Evaluate a string of JavaScript and return result.\n\n @param  js_string  The string of JavaScript to evaluate.\n\n @param  exception  The address of a ULString to store a description of the last exception. Pass\n                    NULL to ignore this. Don't destroy the exception string returned, it's owned\n                    by the View.\n\n @note Don't destroy the returned string, it's owned by the View. This value is reset with every\n       call-- if you want to retain it you should copy the result to a new string via\n       ulCreateStringFromCopy().\n\n @note An example of using this API:\n       <pre>\n         ULString script = ulCreateString(\"1 + 1\");\n         ULString exception;\n         ULString result = ulViewEvaluateScript(view, script, &exception);\n         /* Use the result (\"2\") and exception description (if any) here. */\n         ulDestroyString(script);\n       </pre>\n"]
    pub fn ulViewEvaluateScript(
        view: ULView,
        js_string: ULString,
        exception: *mut ULString,
    ) -> ULString;
}
extern "C" {
    #[doc = "\n Check if can navigate backwards in history.\n"]
    pub fn ulViewCanGoBack(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Check if can navigate forwards in history.\n"]
    pub fn ulViewCanGoForward(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Navigate backwards in history.\n"]
    pub fn ulViewGoBack(view: ULView);
}
extern "C" {
    #[doc = "\n Navigate forwards in history.\n"]
    pub fn ulViewGoForward(view: ULView);
}
extern "C" {
    #[doc = "\n Navigate to arbitrary offset in history.\n"]
    pub fn ulViewGoToHistoryOffset(view: ULView, offset: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\n Reload current page.\n"]
    pub fn ulViewReload(view: ULView);
}
extern "C" {
    #[doc = "\n Stop all page loads.\n"]
    pub fn ulViewStop(view: ULView);
}
extern "C" {
    #[doc = "\n Give focus to the View.\n\n You should call this to give visual indication that the View has input focus (changes active\n text selection colors, for example).\n"]
    pub fn ulViewFocus(view: ULView);
}
extern "C" {
    #[doc = "\n Remove focus from the View and unfocus any focused input elements.\n\n You should call this to give visual indication that the View has lost input focus.\n"]
    pub fn ulViewUnfocus(view: ULView);
}
extern "C" {
    #[doc = "\n Whether or not the View has focus.\n"]
    pub fn ulViewHasFocus(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Whether or not the View has an input element with visible keyboard focus (indicated by a\n blinking caret).\n\n You can use this to decide whether or not the View should consume keyboard input events (useful\n in games with mixed UI and key handling).\n"]
    pub fn ulViewHasInputFocus(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Fire a keyboard event.\n"]
    pub fn ulViewFireKeyEvent(view: ULView, key_event: ULKeyEvent);
}
extern "C" {
    #[doc = "\n Fire a mouse event.\n"]
    pub fn ulViewFireMouseEvent(view: ULView, mouse_event: ULMouseEvent);
}
extern "C" {
    #[doc = "\n Fire a scroll event.\n"]
    pub fn ulViewFireScrollEvent(view: ULView, scroll_event: ULScrollEvent);
}
pub type ULChangeTitleCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, title: ULString),
>;
extern "C" {
    #[doc = "\n Set callback for when the page title changes.\n"]
    pub fn ulViewSetChangeTitleCallback(
        view: ULView,
        callback: ULChangeTitleCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULChangeURLCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, url: ULString),
>;
extern "C" {
    #[doc = "\n Set callback for when the page URL changes.\n"]
    pub fn ulViewSetChangeURLCallback(
        view: ULView,
        callback: ULChangeURLCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULChangeTooltipCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, tooltip: ULString),
>;
extern "C" {
    #[doc = "\n Set callback for when the tooltip changes (usually result of a mouse hover).\n"]
    pub fn ulViewSetChangeTooltipCallback(
        view: ULView,
        callback: ULChangeTooltipCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULChangeCursorCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, cursor: ULCursor),
>;
extern "C" {
    #[doc = "\n Set callback for when the mouse cursor changes.\n"]
    pub fn ulViewSetChangeCursorCallback(
        view: ULView,
        callback: ULChangeCursorCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULAddConsoleMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        source: ULMessageSource,
        level: ULMessageLevel,
        message: ULString,
        line_number: ::std::os::raw::c_uint,
        column_number: ::std::os::raw::c_uint,
        source_id: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when a message is added to the console (useful for JavaScript / network errors\n and debugging).\n"]
    pub fn ulViewSetAddConsoleMessageCallback(
        view: ULView,
        callback: ULAddConsoleMessageCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULCreateChildViewCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        opener_url: ULString,
        target_url: ULString,
        is_popup: bool,
        popup_rect: ULIntRect,
    ) -> ULView,
>;
extern "C" {
    #[doc = "\n Set callback for when the page wants to create a new View.\n\n This is usually the result of a user clicking a link with target=\"_blank\" or by JavaScript\n calling window.open(url).\n\n To allow creation of these new Views, you should create a new View in this callback, resize it\n to your container, and return it. You are responsible for displaying the returned View.\n\n You should return NULL if you want to block the action.\n"]
    pub fn ulViewSetCreateChildViewCallback(
        view: ULView,
        callback: ULCreateChildViewCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULCreateInspectorViewCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        is_local: bool,
        inspected_url: ULString,
    ) -> ULView,
>;
extern "C" {
    #[doc = "\n Set callback for when the page wants to create a new View to display the local inspector in.\n\n You should create a new View in this callback, resize it to your\n container, and return it. You are responsible for displaying the returned View.\n"]
    pub fn ulViewSetCreateInspectorViewCallback(
        view: ULView,
        callback: ULCreateInspectorViewCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULBeginLoadingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when the page begins loading a new URL into a frame.\n"]
    pub fn ulViewSetBeginLoadingCallback(
        view: ULView,
        callback: ULBeginLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULFinishLoadingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when the page finishes loading a URL into a frame.\n"]
    pub fn ulViewSetFinishLoadingCallback(
        view: ULView,
        callback: ULFinishLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULFailLoadingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
        description: ULString,
        error_domain: ULString,
        error_code: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when an error occurs while loading a URL into a frame.\n"]
    pub fn ulViewSetFailLoadingCallback(
        view: ULView,
        callback: ULFailLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULWindowObjectReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when the JavaScript window object is reset for a new page load.\n\n This is called before any scripts are executed on the page and is the earliest time to setup any\n initial JavaScript state or bindings.\n\n The document is not guaranteed to be loaded/parsed at this point. If you need to make any\n JavaScript calls that are dependent on DOM elements or scripts on the page, use DOMReady\n instead.\n\n The window object is lazily initialized (this will not be called on pages with no scripts).\n"]
    pub fn ulViewSetWindowObjectReadyCallback(
        view: ULView,
        callback: ULWindowObjectReadyCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULDOMReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
extern "C" {
    #[doc = "\n Set callback for when all JavaScript has been parsed and the document is ready.\n\n This is the best time to make any JavaScript calls that are dependent on DOM elements or scripts\n on the page.\n"]
    pub fn ulViewSetDOMReadyCallback(
        view: ULView,
        callback: ULDOMReadyCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULUpdateHistoryCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView),
>;
extern "C" {
    #[doc = "\n Set callback for when the history (back/forward state) is modified.\n"]
    pub fn ulViewSetUpdateHistoryCallback(
        view: ULView,
        callback: ULUpdateHistoryCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\n Set whether or not a view should be repainted during the next call to ulRender.\n\n @note  This flag is automatically set whenever the page content changes but you can set it\n        directly in case you need to force a repaint.\n"]
    pub fn ulViewSetNeedsPaint(view: ULView, needs_paint: bool);
}
extern "C" {
    #[doc = "\n Whether or not a view should be painted during the next call to ulRender.\n"]
    pub fn ulViewGetNeedsPaint(view: ULView) -> bool;
}
extern "C" {
    #[doc = "\n Create an Inspector View to inspect / debug this View locally.\n\n This will only succeed if you have the inspector assets in your filesystem-- the inspector\n will look for file:///inspector/Main.html when it first loads.\n\n You must handle ulViewSetCreateInspectorViewCallback so that the library has a View to display\n the inspector in. This function will call the callback only if an inspector view is not\n currently active.\n"]
    pub fn ulViewCreateLocalInspectorView(view: ULView);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Settings {
    _unused: [u8; 0],
}
pub type ULSettings = *mut C_Settings;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_App {
    _unused: [u8; 0],
}
pub type ULApp = *mut C_App;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Window {
    _unused: [u8; 0],
}
pub type ULWindow = *mut C_Window;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Monitor {
    _unused: [u8; 0],
}
pub type ULMonitor = *mut C_Monitor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Overlay {
    _unused: [u8; 0],
}
pub type ULOverlay = *mut C_Overlay;
pub const ULWindowFlags_kWindowFlags_Borderless: ULWindowFlags = 1;
pub const ULWindowFlags_kWindowFlags_Titled: ULWindowFlags = 2;
pub const ULWindowFlags_kWindowFlags_Resizable: ULWindowFlags = 4;
pub const ULWindowFlags_kWindowFlags_Maximizable: ULWindowFlags = 8;
pub const ULWindowFlags_kWindowFlags_Hidden: ULWindowFlags = 16;
#[doc = "\n Window creation flags. @see Window::Create\n"]
pub type ULWindowFlags = ::std::os::raw::c_int;
extern "C" {
    #[doc = "\n Create settings with default values (see <AppCore/App.h>).\n"]
    pub fn ulCreateSettings() -> ULSettings;
}
extern "C" {
    #[doc = "\n Destroy settings.\n"]
    pub fn ulDestroySettings(settings: ULSettings);
}
extern "C" {
    #[doc = "\n Set the name of the developer of this app.\n\n This is used to generate a unique path to store local application data\n on the user's machine.\n\n Default is \"MyCompany\"\n"]
    pub fn ulSettingsSetDeveloperName(settings: ULSettings, name: ULString);
}
extern "C" {
    #[doc = "\n Set the name of this app.\n\n This is used to generate a unique path to store local application data\n on the user's machine.\n\n Default is \"MyApp\"\n"]
    pub fn ulSettingsSetAppName(settings: ULSettings, name: ULString);
}
extern "C" {
    #[doc = "\n Set the root file path for our file system, you should set this to the\n relative path where all of your app data is.\n\n This will be used to resolve all file URLs, eg file:///page.html\n\n @note  The default path is \"./assets/\"\n\n        This relative path is resolved using the following logic:\n         - Windows: relative to the executable path\n         - Linux:   relative to the executable path\n         - macOS:   relative to YourApp.app/Contents/Resources/\n"]
    pub fn ulSettingsSetFileSystemPath(settings: ULSettings, path: ULString);
}
extern "C" {
    #[doc = "\n Set whether or not we should load and compile shaders from the file system\n (eg, from the /shaders/ path, relative to file_system_path).\n\n If this is false (the default), we will instead load pre-compiled shaders\n from memory which speeds up application startup time.\n"]
    pub fn ulSettingsSetLoadShadersFromFileSystem(settings: ULSettings, enabled: bool);
}
extern "C" {
    #[doc = "\n We try to use the GPU renderer when a compatible GPU is detected.\n\n Set this to true to force the engine to always use the CPU renderer.\n"]
    pub fn ulSettingsSetForceCPURenderer(settings: ULSettings, force_cpu: bool);
}
extern "C" {
    #[doc = "\n Create the App singleton.\n\n @param  settings  Settings to customize App runtime behavior. You can pass\n                   NULL for this parameter to use default settings.\n\n @param  config  Config options for the Ultralight renderer. You can pass\n                 NULL for this parameter to use default config.\n\n @note  You should only create one of these per application lifetime.\n\n @note  Certain Config options may be overridden during App creation,\n        most commonly Config::face_winding and Config::device_scale_hint.\n"]
    pub fn ulCreateApp(settings: ULSettings, config: ULConfig) -> ULApp;
}
extern "C" {
    #[doc = "\n Destroy the App instance.\n"]
    pub fn ulDestroyApp(app: ULApp);
}
pub type ULUpdateCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = "\n Set a callback for whenever the App updates. You should update all app\n logic here.\n\n @note  This event is fired right before the run loop calls\n        Renderer::Update and Renderer::Render.\n"]
    pub fn ulAppSetUpdateCallback(
        app: ULApp,
        callback: ULUpdateCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\n Whether or not the App is running.\n"]
    pub fn ulAppIsRunning(app: ULApp) -> bool;
}
extern "C" {
    #[doc = "\n Get the main monitor (this is never NULL).\n\n @note  We'll add monitor enumeration later.\n"]
    pub fn ulAppGetMainMonitor(app: ULApp) -> ULMonitor;
}
extern "C" {
    #[doc = "\n Get the underlying Renderer instance.\n"]
    pub fn ulAppGetRenderer(app: ULApp) -> ULRenderer;
}
extern "C" {
    #[doc = "\n Run the main loop.\n"]
    pub fn ulAppRun(app: ULApp);
}
extern "C" {
    #[doc = "\n Quit the application.\n"]
    pub fn ulAppQuit(app: ULApp);
}
extern "C" {
    #[doc = "\n Get the monitor's DPI scale (1.0 = 100%).\n"]
    pub fn ulMonitorGetScale(monitor: ULMonitor) -> f64;
}
extern "C" {
    #[doc = "\n Get the width of the monitor (in pixels).\n"]
    pub fn ulMonitorGetWidth(monitor: ULMonitor) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height of the monitor (in pixels).\n"]
    pub fn ulMonitorGetHeight(monitor: ULMonitor) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Create a new Window.\n\n @param  monitor       The monitor to create the Window on.\n\n @param  width         The width (in screen coordinates).\n\n @param  height        The height (in screen coordinates).\n\n @param  fullscreen    Whether or not the window is fullscreen.\n\n @param  window_flags  Various window flags.\n"]
    pub fn ulCreateWindow(
        monitor: ULMonitor,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        fullscreen: bool,
        window_flags: ::std::os::raw::c_uint,
    ) -> ULWindow;
}
extern "C" {
    #[doc = "\n Destroy a Window.\n"]
    pub fn ulDestroyWindow(window: ULWindow);
}
pub type ULCloseCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, window: ULWindow),
>;
extern "C" {
    #[doc = "\n Set a callback to be notified when a window closes.\n"]
    pub fn ulWindowSetCloseCallback(
        window: ULWindow,
        callback: ULCloseCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub type ULResizeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        window: ULWindow,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ),
>;
extern "C" {
    #[doc = "\n Set a callback to be notified when a window resizes\n (parameters are passed back in pixels).\n"]
    pub fn ulWindowSetResizeCallback(
        window: ULWindow,
        callback: ULResizeCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\n Get window width (in screen coordinates).\n"]
    pub fn ulWindowGetScreenWidth(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get window width (in pixels).\n"]
    pub fn ulWindowGetWidth(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get window height (in screen coordinates).\n"]
    pub fn ulWindowGetScreenHeight(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get window height (in pixels).\n"]
    pub fn ulWindowGetHeight(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Move the window to a new position (in screen coordinates) relative to the top-left of the\n monitor area.\n"]
    pub fn ulWindowMoveTo(window: ULWindow, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\n Move the window to the center of the monitor.\n"]
    pub fn ulWindowMoveToCenter(arg1: ULWindow);
}
extern "C" {
    #[doc = "\n Get the x-position of the window (in screen coordinates) relative to the top-left of the\n monitor area.\n"]
    pub fn ulWindowGetPositionX(window: ULWindow) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get the y-position of the window (in screen coordinates) relative to the top-left of the\n monitor area.\n"]
    pub fn ulWindowGetPositionY(window: ULWindow) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get whether or not a window is fullscreen.\n"]
    pub fn ulWindowIsFullscreen(window: ULWindow) -> bool;
}
extern "C" {
    #[doc = "\n Get the DPI scale of a window.\n"]
    pub fn ulWindowGetScale(window: ULWindow) -> f64;
}
extern "C" {
    #[doc = "\n Set the window title.\n"]
    pub fn ulWindowSetTitle(window: ULWindow, title: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "\n Set the cursor for a window.\n"]
    pub fn ulWindowSetCursor(window: ULWindow, cursor: ULCursor);
}
extern "C" {
    #[doc = "\n Show the window (if it was previously hidden).\n"]
    pub fn ulWindowShow(window: ULWindow);
}
extern "C" {
    #[doc = "\n Hide the window.\n"]
    pub fn ulWindowHide(window: ULWindow);
}
extern "C" {
    #[doc = "\n Whether or not the window is currently visible (not hidden).\n"]
    pub fn ulWindowIsVisible(window: ULWindow) -> bool;
}
extern "C" {
    #[doc = "\n Close a window.\n"]
    pub fn ulWindowClose(window: ULWindow);
}
extern "C" {
    #[doc = "\n Convert screen coordinates to pixels using the current DPI scale.\n"]
    pub fn ulWindowScreenToPixels(
        window: ULWindow,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Convert pixels to screen coordinates using the current DPI scale.\n"]
    pub fn ulWindowPixelsToScreen(
        window: ULWindow,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get the underlying native window handle.\n\n @note This is:  - HWND on Windows\n                 - NSWindow* on macOS\n                 - GLFWwindow* on Linux\n"]
    pub fn ulWindowGetNativeHandle(window: ULWindow) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Create a new Overlay.\n\n @param  window  The window to create the Overlay in.\n\n @param  width   The width in pixels.\n\n @param  height  The height in pixels.\n\n @param  x       The x-position (offset from the left of the Window), in\n                 pixels.\n\n @param  y       The y-position (offset from the top of the Window), in\n                 pixels.\n\n @note  Each Overlay is essentially a View and an on-screen quad. You should\n        create the Overlay then load content into the underlying View.\n"]
    pub fn ulCreateOverlay(
        window: ULWindow,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ULOverlay;
}
extern "C" {
    #[doc = "\n Create a new Overlay, wrapping an existing View.\n\n @param  window  The window to create the Overlay in. (we currently only\n                 support one window per application)\n\n @param  view    The View to wrap (will use its width and height).\n\n @param  x       The x-position (offset from the left of the Window), in\n                 pixels.\n\n @param  y       The y-position (offset from the top of the Window), in\n                 pixels.\n\n @note  Each Overlay is essentially a View and an on-screen quad. You should\n        create the Overlay then load content into the underlying View.\n"]
    pub fn ulCreateOverlayWithView(
        window: ULWindow,
        view: ULView,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ULOverlay;
}
extern "C" {
    #[doc = "\n Destroy an overlay.\n"]
    pub fn ulDestroyOverlay(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Get the underlying View.\n"]
    pub fn ulOverlayGetView(overlay: ULOverlay) -> ULView;
}
extern "C" {
    #[doc = "\n Get the width (in pixels).\n"]
    pub fn ulOverlayGetWidth(overlay: ULOverlay) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height (in pixels).\n"]
    pub fn ulOverlayGetHeight(overlay: ULOverlay) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the x-position (offset from the left of the Window), in pixels.\n"]
    pub fn ulOverlayGetX(overlay: ULOverlay) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get the y-position (offset from the top of the Window), in pixels.\n"]
    pub fn ulOverlayGetY(overlay: ULOverlay) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Move the overlay to a new position (in pixels).\n"]
    pub fn ulOverlayMoveTo(overlay: ULOverlay, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\n Resize the overlay (and underlying View), dimensions should be\n specified in pixels.\n"]
    pub fn ulOverlayResize(
        overlay: ULOverlay,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n Whether or not the overlay is hidden (not drawn).\n"]
    pub fn ulOverlayIsHidden(overlay: ULOverlay) -> bool;
}
extern "C" {
    #[doc = "\n Hide the overlay (will no longer be drawn).\n"]
    pub fn ulOverlayHide(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Show the overlay.\n"]
    pub fn ulOverlayShow(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Whether or not an overlay has keyboard focus.\n"]
    pub fn ulOverlayHasFocus(overlay: ULOverlay) -> bool;
}
extern "C" {
    #[doc = "\n Grant this overlay exclusive keyboard focus.\n"]
    pub fn ulOverlayFocus(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Remove keyboard focus.\n"]
    pub fn ulOverlayUnfocus(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n This is only needed if you are not calling ulCreateApp().\n\n Initializes the platform font loader and sets it as the current FontLoader.\n"]
    pub fn ulEnablePlatformFontLoader();
}
extern "C" {
    #[doc = "\n This is only needed if you are not calling ulCreateApp().\n\n Initializes the platform file system (needed for loading file:/// URLs) and\n sets it as the current FileSystem.\n\n You can specify a base directory path to resolve relative paths against.\n"]
    pub fn ulEnablePlatformFileSystem(base_dir: ULString);
}
extern "C" {
    #[doc = "\n This is only needed if you are not calling ulCreateApp().\n\n Initializes the default logger (writes the log to a file).\n\n You should specify a writable log path to write the log to\n for example \"./ultralight.log\".\n"]
    pub fn ulEnableDefaultLogger(log_path: ULString);
}
